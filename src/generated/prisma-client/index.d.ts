// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bon: (where?: BonWhereInput) => Promise<boolean>;
  car: (where?: CarWhereInput) => Promise<boolean>;
  dotation: (where?: DotationWhereInput) => Promise<boolean>;
  hold: (where?: HoldWhereInput) => Promise<boolean>;
  holdsOnBons: (where?: HoldsOnBonsWhereInput) => Promise<boolean>;
  log: (where?: LogWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bon: (where: BonWhereUniqueInput) => BonNullablePromise;
  bons: (args?: {
    where?: BonWhereInput;
    orderBy?: BonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bon>;
  bonsConnection: (args?: {
    where?: BonWhereInput;
    orderBy?: BonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BonConnectionPromise;
  car: (where: CarWhereUniqueInput) => CarNullablePromise;
  cars: (args?: {
    where?: CarWhereInput;
    orderBy?: CarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Car>;
  carsConnection: (args?: {
    where?: CarWhereInput;
    orderBy?: CarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CarConnectionPromise;
  dotation: (where: DotationWhereUniqueInput) => DotationNullablePromise;
  dotations: (args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dotation>;
  dotationsConnection: (args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DotationConnectionPromise;
  hold: (where: HoldWhereUniqueInput) => HoldNullablePromise;
  holds: (args?: {
    where?: HoldWhereInput;
    orderBy?: HoldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Hold>;
  holdsConnection: (args?: {
    where?: HoldWhereInput;
    orderBy?: HoldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HoldConnectionPromise;
  holdsOnBons: (
    where: HoldsOnBonsWhereUniqueInput
  ) => HoldsOnBonsNullablePromise;
  holdsOnBonses: (args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HoldsOnBons>;
  holdsOnBonsesConnection: (args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HoldsOnBonsConnectionPromise;
  log: (where: LogWhereUniqueInput) => LogNullablePromise;
  logs: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Log>;
  logsConnection: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LogConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBon: (data: BonCreateInput) => BonPromise;
  updateBon: (args: {
    data: BonUpdateInput;
    where: BonWhereUniqueInput;
  }) => BonPromise;
  updateManyBons: (args: {
    data: BonUpdateManyMutationInput;
    where?: BonWhereInput;
  }) => BatchPayloadPromise;
  upsertBon: (args: {
    where: BonWhereUniqueInput;
    create: BonCreateInput;
    update: BonUpdateInput;
  }) => BonPromise;
  deleteBon: (where: BonWhereUniqueInput) => BonPromise;
  deleteManyBons: (where?: BonWhereInput) => BatchPayloadPromise;
  createCar: (data: CarCreateInput) => CarPromise;
  updateCar: (args: {
    data: CarUpdateInput;
    where: CarWhereUniqueInput;
  }) => CarPromise;
  updateManyCars: (args: {
    data: CarUpdateManyMutationInput;
    where?: CarWhereInput;
  }) => BatchPayloadPromise;
  upsertCar: (args: {
    where: CarWhereUniqueInput;
    create: CarCreateInput;
    update: CarUpdateInput;
  }) => CarPromise;
  deleteCar: (where: CarWhereUniqueInput) => CarPromise;
  deleteManyCars: (where?: CarWhereInput) => BatchPayloadPromise;
  createDotation: (data: DotationCreateInput) => DotationPromise;
  updateDotation: (args: {
    data: DotationUpdateInput;
    where: DotationWhereUniqueInput;
  }) => DotationPromise;
  updateManyDotations: (args: {
    data: DotationUpdateManyMutationInput;
    where?: DotationWhereInput;
  }) => BatchPayloadPromise;
  upsertDotation: (args: {
    where: DotationWhereUniqueInput;
    create: DotationCreateInput;
    update: DotationUpdateInput;
  }) => DotationPromise;
  deleteDotation: (where: DotationWhereUniqueInput) => DotationPromise;
  deleteManyDotations: (where?: DotationWhereInput) => BatchPayloadPromise;
  createHold: (data: HoldCreateInput) => HoldPromise;
  updateHold: (args: {
    data: HoldUpdateInput;
    where: HoldWhereUniqueInput;
  }) => HoldPromise;
  updateManyHolds: (args: {
    data: HoldUpdateManyMutationInput;
    where?: HoldWhereInput;
  }) => BatchPayloadPromise;
  upsertHold: (args: {
    where: HoldWhereUniqueInput;
    create: HoldCreateInput;
    update: HoldUpdateInput;
  }) => HoldPromise;
  deleteHold: (where: HoldWhereUniqueInput) => HoldPromise;
  deleteManyHolds: (where?: HoldWhereInput) => BatchPayloadPromise;
  createHoldsOnBons: (data: HoldsOnBonsCreateInput) => HoldsOnBonsPromise;
  updateHoldsOnBons: (args: {
    data: HoldsOnBonsUpdateInput;
    where: HoldsOnBonsWhereUniqueInput;
  }) => HoldsOnBonsPromise;
  upsertHoldsOnBons: (args: {
    where: HoldsOnBonsWhereUniqueInput;
    create: HoldsOnBonsCreateInput;
    update: HoldsOnBonsUpdateInput;
  }) => HoldsOnBonsPromise;
  deleteHoldsOnBons: (where: HoldsOnBonsWhereUniqueInput) => HoldsOnBonsPromise;
  deleteManyHoldsOnBonses: (
    where?: HoldsOnBonsWhereInput
  ) => BatchPayloadPromise;
  createLog: (data: LogCreateInput) => LogPromise;
  updateLog: (args: {
    data: LogUpdateInput;
    where: LogWhereUniqueInput;
  }) => LogPromise;
  updateManyLogs: (args: {
    data: LogUpdateManyMutationInput;
    where?: LogWhereInput;
  }) => BatchPayloadPromise;
  upsertLog: (args: {
    where: LogWhereUniqueInput;
    create: LogCreateInput;
    update: LogUpdateInput;
  }) => LogPromise;
  deleteLog: (where: LogWhereUniqueInput) => LogPromise;
  deleteManyLogs: (where?: LogWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bon: (
    where?: BonSubscriptionWhereInput
  ) => BonSubscriptionPayloadSubscription;
  car: (
    where?: CarSubscriptionWhereInput
  ) => CarSubscriptionPayloadSubscription;
  dotation: (
    where?: DotationSubscriptionWhereInput
  ) => DotationSubscriptionPayloadSubscription;
  hold: (
    where?: HoldSubscriptionWhereInput
  ) => HoldSubscriptionPayloadSubscription;
  holdsOnBons: (
    where?: HoldsOnBonsSubscriptionWhereInput
  ) => HoldsOnBonsSubscriptionPayloadSubscription;
  log: (
    where?: LogSubscriptionWhereInput
  ) => LogSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "action_ASC"
  | "action_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type BonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "consumed_ASC"
  | "consumed_DESC"
  | "coverage_when_consuming_ASC"
  | "coverage_when_consuming_DESC"
  | "expiration_date_ASC"
  | "expiration_date_DESC"
  | "consumed_date_ASC"
  | "consumed_date_DESC"
  | "emission_date_ASC"
  | "emission_date_DESC"
  | "departure_ASC"
  | "departure_DESC"
  | "destination_ASC"
  | "destination_DESC"
  | "fuel_type_ASC"
  | "fuel_type_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "number_of_liter_ASC"
  | "number_of_liter_DESC"
  | "initial_number_of_liter_ASC"
  | "initial_number_of_liter_DESC"
  | "status_ASC"
  | "status_DESC"
  | "driver_ASC"
  | "driver_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type DotationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "motif_ASC"
  | "motif_DESC"
  | "start_date_ASC"
  | "start_date_DESC"
  | "end_date_ASC"
  | "end_date_DESC"
  | "number_of_liter_dotated_super_ASC"
  | "number_of_liter_dotated_super_DESC"
  | "number_of_liter_received_super_ASC"
  | "number_of_liter_received_super_DESC"
  | "number_of_liter_dotated_gazoil_ASC"
  | "number_of_liter_dotated_gazoil_DESC"
  | "number_of_liter_received_gazoil_ASC"
  | "number_of_liter_received_gazoil_DESC"
  | "number_of_liter_dotated_reserve_super_ASC"
  | "number_of_liter_dotated_reserve_super_DESC"
  | "number_of_liter_received_reserve_super_ASC"
  | "number_of_liter_received_reserve_super_DESC"
  | "number_of_liter_dotated_reserve_gazoil_ASC"
  | "number_of_liter_dotated_reserve_gazoil_DESC"
  | "number_of_liter_received_reserve_gazoil_ASC"
  | "number_of_liter_received_reserve_gazoil_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "grade_ASC"
  | "grade_DESC"
  | "matricule_ASC"
  | "matricule_DESC"
  | "username_ASC"
  | "username_DESC"
  | "fullname_ASC"
  | "fullname_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "reserve_ASC"
  | "reserve_DESC"
  | "role_ASC"
  | "role_DESC"
  | "password_ASC"
  | "password_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type HoldsOnBonsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type CarOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "marque_ASC"
  | "marque_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "type_ASC"
  | "type_DESC"
  | "immatriculation_ASC"
  | "immatriculation_DESC"
  | "kilometrage_ASC"
  | "kilometrage_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type HoldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "localisation_ASC"
  | "localisation_DESC"
  | "super_capacity_ASC"
  | "super_capacity_DESC"
  | "gazoil_capacity_ASC"
  | "gazoil_capacity_DESC"
  | "super_quantity_ASC"
  | "super_quantity_DESC"
  | "gazoil_quantity_ASC"
  | "gazoil_quantity_DESC"
  | "theorical_super_quantity_ASC"
  | "theorical_super_quantity_DESC"
  | "theorical_gazoil_quantity_ASC"
  | "theorical_gazoil_quantity_DESC"
  | "reserve_super_quantity_ASC"
  | "reserve_super_quantity_DESC"
  | "reserve_gazoil_quantity_ASC"
  | "reserve_gazoil_quantity_DESC"
  | "theorical_reserve_super_quantity_ASC"
  | "theorical_reserve_super_quantity_DESC"
  | "theorical_reserve_gazoil_quantity_ASC"
  | "theorical_reserve_gazoil_quantity_DESC"
  | "created_at_ASC"
  | "created_at_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LogWhereInput[] | LogWhereInput>;
  OR?: Maybe<LogWhereInput[] | LogWhereInput>;
  NOT?: Maybe<LogWhereInput[] | LogWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  grade?: Maybe<String>;
  grade_not?: Maybe<String>;
  grade_in?: Maybe<String[] | String>;
  grade_not_in?: Maybe<String[] | String>;
  grade_lt?: Maybe<String>;
  grade_lte?: Maybe<String>;
  grade_gt?: Maybe<String>;
  grade_gte?: Maybe<String>;
  grade_contains?: Maybe<String>;
  grade_not_contains?: Maybe<String>;
  grade_starts_with?: Maybe<String>;
  grade_not_starts_with?: Maybe<String>;
  grade_ends_with?: Maybe<String>;
  grade_not_ends_with?: Maybe<String>;
  matricule?: Maybe<String>;
  matricule_not?: Maybe<String>;
  matricule_in?: Maybe<String[] | String>;
  matricule_not_in?: Maybe<String[] | String>;
  matricule_lt?: Maybe<String>;
  matricule_lte?: Maybe<String>;
  matricule_gt?: Maybe<String>;
  matricule_gte?: Maybe<String>;
  matricule_contains?: Maybe<String>;
  matricule_not_contains?: Maybe<String>;
  matricule_starts_with?: Maybe<String>;
  matricule_not_starts_with?: Maybe<String>;
  matricule_ends_with?: Maybe<String>;
  matricule_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  reserve?: Maybe<Float>;
  reserve_not?: Maybe<Float>;
  reserve_in?: Maybe<Float[] | Float>;
  reserve_not_in?: Maybe<Float[] | Float>;
  reserve_lt?: Maybe<Float>;
  reserve_lte?: Maybe<Float>;
  reserve_gt?: Maybe<Float>;
  reserve_gte?: Maybe<Float>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  logs_every?: Maybe<LogWhereInput>;
  logs_some?: Maybe<LogWhereInput>;
  logs_none?: Maybe<LogWhereInput>;
  bons_every?: Maybe<BonWhereInput>;
  bons_some?: Maybe<BonWhereInput>;
  bons_none?: Maybe<BonWhereInput>;
  dotations_every?: Maybe<DotationWhereInput>;
  dotations_some?: Maybe<DotationWhereInput>;
  dotations_none?: Maybe<DotationWhereInput>;
  hold?: Maybe<HoldWhereInput>;
  notifications_every?: Maybe<NotificationWhereInput>;
  notifications_some?: Maybe<NotificationWhereInput>;
  notifications_none?: Maybe<NotificationWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  consumed?: Maybe<Boolean>;
  consumed_not?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  coverage_when_consuming_not?: Maybe<Float>;
  coverage_when_consuming_in?: Maybe<Float[] | Float>;
  coverage_when_consuming_not_in?: Maybe<Float[] | Float>;
  coverage_when_consuming_lt?: Maybe<Float>;
  coverage_when_consuming_lte?: Maybe<Float>;
  coverage_when_consuming_gt?: Maybe<Float>;
  coverage_when_consuming_gte?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  expiration_date_not?: Maybe<String>;
  expiration_date_in?: Maybe<String[] | String>;
  expiration_date_not_in?: Maybe<String[] | String>;
  expiration_date_lt?: Maybe<String>;
  expiration_date_lte?: Maybe<String>;
  expiration_date_gt?: Maybe<String>;
  expiration_date_gte?: Maybe<String>;
  expiration_date_contains?: Maybe<String>;
  expiration_date_not_contains?: Maybe<String>;
  expiration_date_starts_with?: Maybe<String>;
  expiration_date_not_starts_with?: Maybe<String>;
  expiration_date_ends_with?: Maybe<String>;
  expiration_date_not_ends_with?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  consumed_date_not?: Maybe<DateTimeInput>;
  consumed_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  consumed_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  consumed_date_lt?: Maybe<DateTimeInput>;
  consumed_date_lte?: Maybe<DateTimeInput>;
  consumed_date_gt?: Maybe<DateTimeInput>;
  consumed_date_gte?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  emission_date_not?: Maybe<DateTimeInput>;
  emission_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emission_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emission_date_lt?: Maybe<DateTimeInput>;
  emission_date_lte?: Maybe<DateTimeInput>;
  emission_date_gt?: Maybe<DateTimeInput>;
  emission_date_gte?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  departure_not?: Maybe<String>;
  departure_in?: Maybe<String[] | String>;
  departure_not_in?: Maybe<String[] | String>;
  departure_lt?: Maybe<String>;
  departure_lte?: Maybe<String>;
  departure_gt?: Maybe<String>;
  departure_gte?: Maybe<String>;
  departure_contains?: Maybe<String>;
  departure_not_contains?: Maybe<String>;
  departure_starts_with?: Maybe<String>;
  departure_not_starts_with?: Maybe<String>;
  departure_ends_with?: Maybe<String>;
  departure_not_ends_with?: Maybe<String>;
  destination?: Maybe<String>;
  destination_not?: Maybe<String>;
  destination_in?: Maybe<String[] | String>;
  destination_not_in?: Maybe<String[] | String>;
  destination_lt?: Maybe<String>;
  destination_lte?: Maybe<String>;
  destination_gt?: Maybe<String>;
  destination_gte?: Maybe<String>;
  destination_contains?: Maybe<String>;
  destination_not_contains?: Maybe<String>;
  destination_starts_with?: Maybe<String>;
  destination_not_starts_with?: Maybe<String>;
  destination_ends_with?: Maybe<String>;
  destination_not_ends_with?: Maybe<String>;
  fuel_type?: Maybe<String>;
  fuel_type_not?: Maybe<String>;
  fuel_type_in?: Maybe<String[] | String>;
  fuel_type_not_in?: Maybe<String[] | String>;
  fuel_type_lt?: Maybe<String>;
  fuel_type_lte?: Maybe<String>;
  fuel_type_gt?: Maybe<String>;
  fuel_type_gte?: Maybe<String>;
  fuel_type_contains?: Maybe<String>;
  fuel_type_not_contains?: Maybe<String>;
  fuel_type_starts_with?: Maybe<String>;
  fuel_type_not_starts_with?: Maybe<String>;
  fuel_type_ends_with?: Maybe<String>;
  fuel_type_not_ends_with?: Maybe<String>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  number_of_liter_not?: Maybe<Float>;
  number_of_liter_in?: Maybe<Float[] | Float>;
  number_of_liter_not_in?: Maybe<Float[] | Float>;
  number_of_liter_lt?: Maybe<Float>;
  number_of_liter_lte?: Maybe<Float>;
  number_of_liter_gt?: Maybe<Float>;
  number_of_liter_gte?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  initial_number_of_liter_not?: Maybe<Float>;
  initial_number_of_liter_in?: Maybe<Float[] | Float>;
  initial_number_of_liter_not_in?: Maybe<Float[] | Float>;
  initial_number_of_liter_lt?: Maybe<Float>;
  initial_number_of_liter_lte?: Maybe<Float>;
  initial_number_of_liter_gt?: Maybe<Float>;
  initial_number_of_liter_gte?: Maybe<Float>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  holds_every?: Maybe<HoldsOnBonsWhereInput>;
  holds_some?: Maybe<HoldsOnBonsWhereInput>;
  holds_none?: Maybe<HoldsOnBonsWhereInput>;
  driver?: Maybe<String>;
  driver_not?: Maybe<String>;
  driver_in?: Maybe<String[] | String>;
  driver_not_in?: Maybe<String[] | String>;
  driver_lt?: Maybe<String>;
  driver_lte?: Maybe<String>;
  driver_gt?: Maybe<String>;
  driver_gte?: Maybe<String>;
  driver_contains?: Maybe<String>;
  driver_not_contains?: Maybe<String>;
  driver_starts_with?: Maybe<String>;
  driver_not_starts_with?: Maybe<String>;
  driver_ends_with?: Maybe<String>;
  driver_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BonWhereInput[] | BonWhereInput>;
  OR?: Maybe<BonWhereInput[] | BonWhereInput>;
  NOT?: Maybe<BonWhereInput[] | BonWhereInput>;
}

export interface HoldsOnBonsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  hold?: Maybe<HoldWhereInput>;
  bon?: Maybe<BonWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HoldsOnBonsWhereInput[] | HoldsOnBonsWhereInput>;
  OR?: Maybe<HoldsOnBonsWhereInput[] | HoldsOnBonsWhereInput>;
  NOT?: Maybe<HoldsOnBonsWhereInput[] | HoldsOnBonsWhereInput>;
}

export interface HoldWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  localisation?: Maybe<String>;
  localisation_not?: Maybe<String>;
  localisation_in?: Maybe<String[] | String>;
  localisation_not_in?: Maybe<String[] | String>;
  localisation_lt?: Maybe<String>;
  localisation_lte?: Maybe<String>;
  localisation_gt?: Maybe<String>;
  localisation_gte?: Maybe<String>;
  localisation_contains?: Maybe<String>;
  localisation_not_contains?: Maybe<String>;
  localisation_starts_with?: Maybe<String>;
  localisation_not_starts_with?: Maybe<String>;
  localisation_ends_with?: Maybe<String>;
  localisation_not_ends_with?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  super_capacity_not?: Maybe<Float>;
  super_capacity_in?: Maybe<Float[] | Float>;
  super_capacity_not_in?: Maybe<Float[] | Float>;
  super_capacity_lt?: Maybe<Float>;
  super_capacity_lte?: Maybe<Float>;
  super_capacity_gt?: Maybe<Float>;
  super_capacity_gte?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  gazoil_capacity_not?: Maybe<Float>;
  gazoil_capacity_in?: Maybe<Float[] | Float>;
  gazoil_capacity_not_in?: Maybe<Float[] | Float>;
  gazoil_capacity_lt?: Maybe<Float>;
  gazoil_capacity_lte?: Maybe<Float>;
  gazoil_capacity_gt?: Maybe<Float>;
  gazoil_capacity_gte?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  super_quantity_not?: Maybe<Float>;
  super_quantity_in?: Maybe<Float[] | Float>;
  super_quantity_not_in?: Maybe<Float[] | Float>;
  super_quantity_lt?: Maybe<Float>;
  super_quantity_lte?: Maybe<Float>;
  super_quantity_gt?: Maybe<Float>;
  super_quantity_gte?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  gazoil_quantity_not?: Maybe<Float>;
  gazoil_quantity_in?: Maybe<Float[] | Float>;
  gazoil_quantity_not_in?: Maybe<Float[] | Float>;
  gazoil_quantity_lt?: Maybe<Float>;
  gazoil_quantity_lte?: Maybe<Float>;
  gazoil_quantity_gt?: Maybe<Float>;
  gazoil_quantity_gte?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_super_quantity_not?: Maybe<Float>;
  theorical_super_quantity_in?: Maybe<Float[] | Float>;
  theorical_super_quantity_not_in?: Maybe<Float[] | Float>;
  theorical_super_quantity_lt?: Maybe<Float>;
  theorical_super_quantity_lte?: Maybe<Float>;
  theorical_super_quantity_gt?: Maybe<Float>;
  theorical_super_quantity_gte?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  theorical_gazoil_quantity_not?: Maybe<Float>;
  theorical_gazoil_quantity_in?: Maybe<Float[] | Float>;
  theorical_gazoil_quantity_not_in?: Maybe<Float[] | Float>;
  theorical_gazoil_quantity_lt?: Maybe<Float>;
  theorical_gazoil_quantity_lte?: Maybe<Float>;
  theorical_gazoil_quantity_gt?: Maybe<Float>;
  theorical_gazoil_quantity_gte?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_super_quantity_not?: Maybe<Float>;
  reserve_super_quantity_in?: Maybe<Float[] | Float>;
  reserve_super_quantity_not_in?: Maybe<Float[] | Float>;
  reserve_super_quantity_lt?: Maybe<Float>;
  reserve_super_quantity_lte?: Maybe<Float>;
  reserve_super_quantity_gt?: Maybe<Float>;
  reserve_super_quantity_gte?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  reserve_gazoil_quantity_not?: Maybe<Float>;
  reserve_gazoil_quantity_in?: Maybe<Float[] | Float>;
  reserve_gazoil_quantity_not_in?: Maybe<Float[] | Float>;
  reserve_gazoil_quantity_lt?: Maybe<Float>;
  reserve_gazoil_quantity_lte?: Maybe<Float>;
  reserve_gazoil_quantity_gt?: Maybe<Float>;
  reserve_gazoil_quantity_gte?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity_not?: Maybe<Float>;
  theorical_reserve_super_quantity_in?: Maybe<Float[] | Float>;
  theorical_reserve_super_quantity_not_in?: Maybe<Float[] | Float>;
  theorical_reserve_super_quantity_lt?: Maybe<Float>;
  theorical_reserve_super_quantity_lte?: Maybe<Float>;
  theorical_reserve_super_quantity_gt?: Maybe<Float>;
  theorical_reserve_super_quantity_gte?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity_not?: Maybe<Float>;
  theorical_reserve_gazoil_quantity_in?: Maybe<Float[] | Float>;
  theorical_reserve_gazoil_quantity_not_in?: Maybe<Float[] | Float>;
  theorical_reserve_gazoil_quantity_lt?: Maybe<Float>;
  theorical_reserve_gazoil_quantity_lte?: Maybe<Float>;
  theorical_reserve_gazoil_quantity_gt?: Maybe<Float>;
  theorical_reserve_gazoil_quantity_gte?: Maybe<Float>;
  user_every?: Maybe<UserWhereInput>;
  user_some?: Maybe<UserWhereInput>;
  user_none?: Maybe<UserWhereInput>;
  bons_every?: Maybe<HoldsOnBonsWhereInput>;
  bons_some?: Maybe<HoldsOnBonsWhereInput>;
  bons_none?: Maybe<HoldsOnBonsWhereInput>;
  cars_every?: Maybe<CarWhereInput>;
  cars_some?: Maybe<CarWhereInput>;
  cars_none?: Maybe<CarWhereInput>;
  dotations_every?: Maybe<DotationWhereInput>;
  dotations_some?: Maybe<DotationWhereInput>;
  dotations_none?: Maybe<DotationWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HoldWhereInput[] | HoldWhereInput>;
  OR?: Maybe<HoldWhereInput[] | HoldWhereInput>;
  NOT?: Maybe<HoldWhereInput[] | HoldWhereInput>;
}

export interface CarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  hold?: Maybe<HoldWhereInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  marque?: Maybe<String>;
  marque_not?: Maybe<String>;
  marque_in?: Maybe<String[] | String>;
  marque_not_in?: Maybe<String[] | String>;
  marque_lt?: Maybe<String>;
  marque_lte?: Maybe<String>;
  marque_gt?: Maybe<String>;
  marque_gte?: Maybe<String>;
  marque_contains?: Maybe<String>;
  marque_not_contains?: Maybe<String>;
  marque_starts_with?: Maybe<String>;
  marque_not_starts_with?: Maybe<String>;
  marque_ends_with?: Maybe<String>;
  marque_not_ends_with?: Maybe<String>;
  capacity?: Maybe<Float>;
  capacity_not?: Maybe<Float>;
  capacity_in?: Maybe<Float[] | Float>;
  capacity_not_in?: Maybe<Float[] | Float>;
  capacity_lt?: Maybe<Float>;
  capacity_lte?: Maybe<Float>;
  capacity_gt?: Maybe<Float>;
  capacity_gte?: Maybe<Float>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  immatriculation?: Maybe<String>;
  immatriculation_not?: Maybe<String>;
  immatriculation_in?: Maybe<String[] | String>;
  immatriculation_not_in?: Maybe<String[] | String>;
  immatriculation_lt?: Maybe<String>;
  immatriculation_lte?: Maybe<String>;
  immatriculation_gt?: Maybe<String>;
  immatriculation_gte?: Maybe<String>;
  immatriculation_contains?: Maybe<String>;
  immatriculation_not_contains?: Maybe<String>;
  immatriculation_starts_with?: Maybe<String>;
  immatriculation_not_starts_with?: Maybe<String>;
  immatriculation_ends_with?: Maybe<String>;
  immatriculation_not_ends_with?: Maybe<String>;
  kilometrage?: Maybe<Float>;
  kilometrage_not?: Maybe<Float>;
  kilometrage_in?: Maybe<Float[] | Float>;
  kilometrage_not_in?: Maybe<Float[] | Float>;
  kilometrage_lt?: Maybe<Float>;
  kilometrage_lte?: Maybe<Float>;
  kilometrage_gt?: Maybe<Float>;
  kilometrage_gte?: Maybe<Float>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CarWhereInput[] | CarWhereInput>;
  OR?: Maybe<CarWhereInput[] | CarWhereInput>;
  NOT?: Maybe<CarWhereInput[] | CarWhereInput>;
}

export interface DotationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  motif?: Maybe<String>;
  motif_not?: Maybe<String>;
  motif_in?: Maybe<String[] | String>;
  motif_not_in?: Maybe<String[] | String>;
  motif_lt?: Maybe<String>;
  motif_lte?: Maybe<String>;
  motif_gt?: Maybe<String>;
  motif_gte?: Maybe<String>;
  motif_contains?: Maybe<String>;
  motif_not_contains?: Maybe<String>;
  motif_starts_with?: Maybe<String>;
  motif_not_starts_with?: Maybe<String>;
  motif_ends_with?: Maybe<String>;
  motif_not_ends_with?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  start_date_not?: Maybe<DateTimeInput>;
  start_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_date_lt?: Maybe<DateTimeInput>;
  start_date_lte?: Maybe<DateTimeInput>;
  start_date_gt?: Maybe<DateTimeInput>;
  start_date_gte?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  end_date_not?: Maybe<DateTimeInput>;
  end_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_date_lt?: Maybe<DateTimeInput>;
  end_date_lte?: Maybe<DateTimeInput>;
  end_date_gt?: Maybe<DateTimeInput>;
  end_date_gte?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_dotated_super_not?: Maybe<Float>;
  number_of_liter_dotated_super_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_super_lt?: Maybe<Float>;
  number_of_liter_dotated_super_lte?: Maybe<Float>;
  number_of_liter_dotated_super_gt?: Maybe<Float>;
  number_of_liter_dotated_super_gte?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_received_super_not?: Maybe<Float>;
  number_of_liter_received_super_in?: Maybe<Float[] | Float>;
  number_of_liter_received_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_super_lt?: Maybe<Float>;
  number_of_liter_received_super_lte?: Maybe<Float>;
  number_of_liter_received_super_gt?: Maybe<Float>;
  number_of_liter_received_super_gte?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_dotated_gazoil_not?: Maybe<Float>;
  number_of_liter_dotated_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_gazoil_lt?: Maybe<Float>;
  number_of_liter_dotated_gazoil_lte?: Maybe<Float>;
  number_of_liter_dotated_gazoil_gt?: Maybe<Float>;
  number_of_liter_dotated_gazoil_gte?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil_not?: Maybe<Float>;
  number_of_liter_received_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_received_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_gazoil_lt?: Maybe<Float>;
  number_of_liter_received_gazoil_lte?: Maybe<Float>;
  number_of_liter_received_gazoil_gt?: Maybe<Float>;
  number_of_liter_received_gazoil_gte?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_not?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_super_lt?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_lte?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_gt?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_gte?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super_not?: Maybe<Float>;
  number_of_liter_received_reserve_super_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_super_lt?: Maybe<Float>;
  number_of_liter_received_reserve_super_lte?: Maybe<Float>;
  number_of_liter_received_reserve_super_gt?: Maybe<Float>;
  number_of_liter_received_reserve_super_gte?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_not?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_gazoil_lt?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_lte?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_gt?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_gte?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_not?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_gazoil_lt?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_lte?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_gt?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  hold?: Maybe<HoldWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DotationWhereInput[] | DotationWhereInput>;
  OR?: Maybe<DotationWhereInput[] | DotationWhereInput>;
  NOT?: Maybe<DotationWhereInput[] | DotationWhereInput>;
}

export interface NotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  OR?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  NOT?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export type CarWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  immatriculation?: Maybe<String>;
}>;

export type DotationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type HoldWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type HoldsOnBonsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  matricule?: Maybe<String>;
  phone?: Maybe<String>;
}>;

export interface BonCreateInput {
  id?: Maybe<ID_Input>;
  consumed: Boolean;
  coverage_when_consuming: Float;
  expiration_date: String;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date: DateTimeInput;
  departure: String;
  destination: String;
  fuel_type: String;
  reason: String;
  number_of_liter: Float;
  initial_number_of_liter: Float;
  status: Boolean;
  user: UserCreateOneWithoutBonsInput;
  holds?: Maybe<HoldsOnBonsCreateManyWithoutBonInput>;
  driver: String;
}

export interface UserCreateOneWithoutBonsInput {
  create?: Maybe<UserCreateWithoutBonsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutBonsInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  logs?: Maybe<LogCreateManyWithoutUserInput>;
  dotations?: Maybe<DotationCreateManyWithoutUserInput>;
  hold?: Maybe<HoldCreateOneWithoutUserInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
}

export interface LogCreateManyWithoutUserInput {
  create?: Maybe<LogCreateWithoutUserInput[] | LogCreateWithoutUserInput>;
  connect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
}

export interface LogCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  action: String;
}

export interface DotationCreateManyWithoutUserInput {
  create?: Maybe<
    DotationCreateWithoutUserInput[] | DotationCreateWithoutUserInput
  >;
  connect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
}

export interface DotationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  motif: String;
  start_date: DateTimeInput;
  end_date: DateTimeInput;
  number_of_liter_dotated_super: Float;
  number_of_liter_received_super: Float;
  number_of_liter_dotated_gazoil: Float;
  number_of_liter_received_gazoil: Float;
  number_of_liter_dotated_reserve_super: Float;
  number_of_liter_received_reserve_super: Float;
  number_of_liter_dotated_reserve_gazoil: Float;
  number_of_liter_received_reserve_gazoil: Float;
  hold?: Maybe<HoldCreateOneWithoutDotationsInput>;
}

export interface HoldCreateOneWithoutDotationsInput {
  create?: Maybe<HoldCreateWithoutDotationsInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldCreateWithoutDotationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  user?: Maybe<UserCreateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsCreateManyWithoutHoldInput>;
  cars?: Maybe<CarCreateManyWithoutHoldInput>;
}

export interface UserCreateManyWithoutHoldInput {
  create?: Maybe<UserCreateWithoutHoldInput[] | UserCreateWithoutHoldInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutHoldInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  logs?: Maybe<LogCreateManyWithoutUserInput>;
  bons?: Maybe<BonCreateManyWithoutUserInput>;
  dotations?: Maybe<DotationCreateManyWithoutUserInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
}

export interface BonCreateManyWithoutUserInput {
  create?: Maybe<BonCreateWithoutUserInput[] | BonCreateWithoutUserInput>;
  connect?: Maybe<BonWhereUniqueInput[] | BonWhereUniqueInput>;
}

export interface BonCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  consumed: Boolean;
  coverage_when_consuming: Float;
  expiration_date: String;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date: DateTimeInput;
  departure: String;
  destination: String;
  fuel_type: String;
  reason: String;
  number_of_liter: Float;
  initial_number_of_liter: Float;
  status: Boolean;
  holds?: Maybe<HoldsOnBonsCreateManyWithoutBonInput>;
  driver: String;
}

export interface HoldsOnBonsCreateManyWithoutBonInput {
  create?: Maybe<
    HoldsOnBonsCreateWithoutBonInput[] | HoldsOnBonsCreateWithoutBonInput
  >;
  connect?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
}

export interface HoldsOnBonsCreateWithoutBonInput {
  id?: Maybe<ID_Input>;
  hold: HoldCreateOneWithoutBonsInput;
}

export interface HoldCreateOneWithoutBonsInput {
  create?: Maybe<HoldCreateWithoutBonsInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldCreateWithoutBonsInput {
  id?: Maybe<ID_Input>;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  user?: Maybe<UserCreateManyWithoutHoldInput>;
  cars?: Maybe<CarCreateManyWithoutHoldInput>;
  dotations?: Maybe<DotationCreateManyWithoutHoldInput>;
}

export interface CarCreateManyWithoutHoldInput {
  create?: Maybe<CarCreateWithoutHoldInput[] | CarCreateWithoutHoldInput>;
  connect?: Maybe<CarWhereUniqueInput[] | CarWhereUniqueInput>;
}

export interface CarCreateWithoutHoldInput {
  id?: Maybe<ID_Input>;
  image: String;
  marque: String;
  capacity: Float;
  type: String;
  immatriculation: String;
  kilometrage: Float;
}

export interface DotationCreateManyWithoutHoldInput {
  create?: Maybe<
    DotationCreateWithoutHoldInput[] | DotationCreateWithoutHoldInput
  >;
  connect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
}

export interface DotationCreateWithoutHoldInput {
  id?: Maybe<ID_Input>;
  motif: String;
  start_date: DateTimeInput;
  end_date: DateTimeInput;
  number_of_liter_dotated_super: Float;
  number_of_liter_received_super: Float;
  number_of_liter_dotated_gazoil: Float;
  number_of_liter_received_gazoil: Float;
  number_of_liter_dotated_reserve_super: Float;
  number_of_liter_received_reserve_super: Float;
  number_of_liter_dotated_reserve_gazoil: Float;
  number_of_liter_received_reserve_gazoil: Float;
  user?: Maybe<UserCreateOneWithoutDotationsInput>;
}

export interface UserCreateOneWithoutDotationsInput {
  create?: Maybe<UserCreateWithoutDotationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutDotationsInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  logs?: Maybe<LogCreateManyWithoutUserInput>;
  bons?: Maybe<BonCreateManyWithoutUserInput>;
  hold?: Maybe<HoldCreateOneWithoutUserInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
}

export interface HoldCreateOneWithoutUserInput {
  create?: Maybe<HoldCreateWithoutUserInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  bons?: Maybe<HoldsOnBonsCreateManyWithoutHoldInput>;
  cars?: Maybe<CarCreateManyWithoutHoldInput>;
  dotations?: Maybe<DotationCreateManyWithoutHoldInput>;
}

export interface HoldsOnBonsCreateManyWithoutHoldInput {
  create?: Maybe<
    HoldsOnBonsCreateWithoutHoldInput[] | HoldsOnBonsCreateWithoutHoldInput
  >;
  connect?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
}

export interface HoldsOnBonsCreateWithoutHoldInput {
  id?: Maybe<ID_Input>;
  bon: BonCreateOneWithoutHoldsInput;
}

export interface BonCreateOneWithoutHoldsInput {
  create?: Maybe<BonCreateWithoutHoldsInput>;
  connect?: Maybe<BonWhereUniqueInput>;
}

export interface BonCreateWithoutHoldsInput {
  id?: Maybe<ID_Input>;
  consumed: Boolean;
  coverage_when_consuming: Float;
  expiration_date: String;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date: DateTimeInput;
  departure: String;
  destination: String;
  fuel_type: String;
  reason: String;
  number_of_liter: Float;
  initial_number_of_liter: Float;
  status: Boolean;
  user: UserCreateOneWithoutBonsInput;
  driver: String;
}

export interface NotificationCreateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
}

export interface NotificationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  message: String;
}

export interface BonUpdateInput {
  consumed?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  destination?: Maybe<String>;
  fuel_type?: Maybe<String>;
  reason?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  status?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutBonsInput>;
  holds?: Maybe<HoldsOnBonsUpdateManyWithoutBonInput>;
  driver?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutBonsInput {
  create?: Maybe<UserCreateWithoutBonsInput>;
  update?: Maybe<UserUpdateWithoutBonsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBonsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutBonsDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  logs?: Maybe<LogUpdateManyWithoutUserInput>;
  dotations?: Maybe<DotationUpdateManyWithoutUserInput>;
  hold?: Maybe<HoldUpdateOneWithoutUserInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
}

export interface LogUpdateManyWithoutUserInput {
  create?: Maybe<LogCreateWithoutUserInput[] | LogCreateWithoutUserInput>;
  delete?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  connect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  set?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  disconnect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  update?: Maybe<
    | LogUpdateWithWhereUniqueWithoutUserInput[]
    | LogUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | LogUpsertWithWhereUniqueWithoutUserInput[]
    | LogUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  updateMany?: Maybe<
    LogUpdateManyWithWhereNestedInput[] | LogUpdateManyWithWhereNestedInput
  >;
}

export interface LogUpdateWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput;
  data: LogUpdateWithoutUserDataInput;
}

export interface LogUpdateWithoutUserDataInput {
  action?: Maybe<String>;
}

export interface LogUpsertWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput;
  update: LogUpdateWithoutUserDataInput;
  create: LogCreateWithoutUserInput;
}

export interface LogScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  OR?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  NOT?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
}

export interface LogUpdateManyWithWhereNestedInput {
  where: LogScalarWhereInput;
  data: LogUpdateManyDataInput;
}

export interface LogUpdateManyDataInput {
  action?: Maybe<String>;
}

export interface DotationUpdateManyWithoutUserInput {
  create?: Maybe<
    DotationCreateWithoutUserInput[] | DotationCreateWithoutUserInput
  >;
  delete?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  connect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  set?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  disconnect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  update?: Maybe<
    | DotationUpdateWithWhereUniqueWithoutUserInput[]
    | DotationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | DotationUpsertWithWhereUniqueWithoutUserInput[]
    | DotationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<DotationScalarWhereInput[] | DotationScalarWhereInput>;
  updateMany?: Maybe<
    | DotationUpdateManyWithWhereNestedInput[]
    | DotationUpdateManyWithWhereNestedInput
  >;
}

export interface DotationUpdateWithWhereUniqueWithoutUserInput {
  where: DotationWhereUniqueInput;
  data: DotationUpdateWithoutUserDataInput;
}

export interface DotationUpdateWithoutUserDataInput {
  motif?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
  hold?: Maybe<HoldUpdateOneWithoutDotationsInput>;
}

export interface HoldUpdateOneWithoutDotationsInput {
  create?: Maybe<HoldCreateWithoutDotationsInput>;
  update?: Maybe<HoldUpdateWithoutDotationsDataInput>;
  upsert?: Maybe<HoldUpsertWithoutDotationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldUpdateWithoutDotationsDataInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  user?: Maybe<UserUpdateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsUpdateManyWithoutHoldInput>;
  cars?: Maybe<CarUpdateManyWithoutHoldInput>;
}

export interface UserUpdateManyWithoutHoldInput {
  create?: Maybe<UserCreateWithoutHoldInput[] | UserCreateWithoutHoldInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutHoldInput[]
    | UserUpdateWithWhereUniqueWithoutHoldInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutHoldInput[]
    | UserUpsertWithWhereUniqueWithoutHoldInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutHoldInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutHoldDataInput;
}

export interface UserUpdateWithoutHoldDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  logs?: Maybe<LogUpdateManyWithoutUserInput>;
  bons?: Maybe<BonUpdateManyWithoutUserInput>;
  dotations?: Maybe<DotationUpdateManyWithoutUserInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
}

export interface BonUpdateManyWithoutUserInput {
  create?: Maybe<BonCreateWithoutUserInput[] | BonCreateWithoutUserInput>;
  delete?: Maybe<BonWhereUniqueInput[] | BonWhereUniqueInput>;
  connect?: Maybe<BonWhereUniqueInput[] | BonWhereUniqueInput>;
  set?: Maybe<BonWhereUniqueInput[] | BonWhereUniqueInput>;
  disconnect?: Maybe<BonWhereUniqueInput[] | BonWhereUniqueInput>;
  update?: Maybe<
    | BonUpdateWithWhereUniqueWithoutUserInput[]
    | BonUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | BonUpsertWithWhereUniqueWithoutUserInput[]
    | BonUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<BonScalarWhereInput[] | BonScalarWhereInput>;
  updateMany?: Maybe<
    BonUpdateManyWithWhereNestedInput[] | BonUpdateManyWithWhereNestedInput
  >;
}

export interface BonUpdateWithWhereUniqueWithoutUserInput {
  where: BonWhereUniqueInput;
  data: BonUpdateWithoutUserDataInput;
}

export interface BonUpdateWithoutUserDataInput {
  consumed?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  destination?: Maybe<String>;
  fuel_type?: Maybe<String>;
  reason?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  status?: Maybe<Boolean>;
  holds?: Maybe<HoldsOnBonsUpdateManyWithoutBonInput>;
  driver?: Maybe<String>;
}

export interface HoldsOnBonsUpdateManyWithoutBonInput {
  create?: Maybe<
    HoldsOnBonsCreateWithoutBonInput[] | HoldsOnBonsCreateWithoutBonInput
  >;
  delete?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  connect?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  set?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  disconnect?: Maybe<
    HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput
  >;
  update?: Maybe<
    | HoldsOnBonsUpdateWithWhereUniqueWithoutBonInput[]
    | HoldsOnBonsUpdateWithWhereUniqueWithoutBonInput
  >;
  upsert?: Maybe<
    | HoldsOnBonsUpsertWithWhereUniqueWithoutBonInput[]
    | HoldsOnBonsUpsertWithWhereUniqueWithoutBonInput
  >;
  deleteMany?: Maybe<
    HoldsOnBonsScalarWhereInput[] | HoldsOnBonsScalarWhereInput
  >;
}

export interface HoldsOnBonsUpdateWithWhereUniqueWithoutBonInput {
  where: HoldsOnBonsWhereUniqueInput;
  data: HoldsOnBonsUpdateWithoutBonDataInput;
}

export interface HoldsOnBonsUpdateWithoutBonDataInput {
  hold?: Maybe<HoldUpdateOneRequiredWithoutBonsInput>;
}

export interface HoldUpdateOneRequiredWithoutBonsInput {
  create?: Maybe<HoldCreateWithoutBonsInput>;
  update?: Maybe<HoldUpdateWithoutBonsDataInput>;
  upsert?: Maybe<HoldUpsertWithoutBonsInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldUpdateWithoutBonsDataInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  user?: Maybe<UserUpdateManyWithoutHoldInput>;
  cars?: Maybe<CarUpdateManyWithoutHoldInput>;
  dotations?: Maybe<DotationUpdateManyWithoutHoldInput>;
}

export interface CarUpdateManyWithoutHoldInput {
  create?: Maybe<CarCreateWithoutHoldInput[] | CarCreateWithoutHoldInput>;
  delete?: Maybe<CarWhereUniqueInput[] | CarWhereUniqueInput>;
  connect?: Maybe<CarWhereUniqueInput[] | CarWhereUniqueInput>;
  set?: Maybe<CarWhereUniqueInput[] | CarWhereUniqueInput>;
  disconnect?: Maybe<CarWhereUniqueInput[] | CarWhereUniqueInput>;
  update?: Maybe<
    | CarUpdateWithWhereUniqueWithoutHoldInput[]
    | CarUpdateWithWhereUniqueWithoutHoldInput
  >;
  upsert?: Maybe<
    | CarUpsertWithWhereUniqueWithoutHoldInput[]
    | CarUpsertWithWhereUniqueWithoutHoldInput
  >;
  deleteMany?: Maybe<CarScalarWhereInput[] | CarScalarWhereInput>;
  updateMany?: Maybe<
    CarUpdateManyWithWhereNestedInput[] | CarUpdateManyWithWhereNestedInput
  >;
}

export interface CarUpdateWithWhereUniqueWithoutHoldInput {
  where: CarWhereUniqueInput;
  data: CarUpdateWithoutHoldDataInput;
}

export interface CarUpdateWithoutHoldDataInput {
  image?: Maybe<String>;
  marque?: Maybe<String>;
  capacity?: Maybe<Float>;
  type?: Maybe<String>;
  immatriculation?: Maybe<String>;
  kilometrage?: Maybe<Float>;
}

export interface CarUpsertWithWhereUniqueWithoutHoldInput {
  where: CarWhereUniqueInput;
  update: CarUpdateWithoutHoldDataInput;
  create: CarCreateWithoutHoldInput;
}

export interface CarScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  marque?: Maybe<String>;
  marque_not?: Maybe<String>;
  marque_in?: Maybe<String[] | String>;
  marque_not_in?: Maybe<String[] | String>;
  marque_lt?: Maybe<String>;
  marque_lte?: Maybe<String>;
  marque_gt?: Maybe<String>;
  marque_gte?: Maybe<String>;
  marque_contains?: Maybe<String>;
  marque_not_contains?: Maybe<String>;
  marque_starts_with?: Maybe<String>;
  marque_not_starts_with?: Maybe<String>;
  marque_ends_with?: Maybe<String>;
  marque_not_ends_with?: Maybe<String>;
  capacity?: Maybe<Float>;
  capacity_not?: Maybe<Float>;
  capacity_in?: Maybe<Float[] | Float>;
  capacity_not_in?: Maybe<Float[] | Float>;
  capacity_lt?: Maybe<Float>;
  capacity_lte?: Maybe<Float>;
  capacity_gt?: Maybe<Float>;
  capacity_gte?: Maybe<Float>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  immatriculation?: Maybe<String>;
  immatriculation_not?: Maybe<String>;
  immatriculation_in?: Maybe<String[] | String>;
  immatriculation_not_in?: Maybe<String[] | String>;
  immatriculation_lt?: Maybe<String>;
  immatriculation_lte?: Maybe<String>;
  immatriculation_gt?: Maybe<String>;
  immatriculation_gte?: Maybe<String>;
  immatriculation_contains?: Maybe<String>;
  immatriculation_not_contains?: Maybe<String>;
  immatriculation_starts_with?: Maybe<String>;
  immatriculation_not_starts_with?: Maybe<String>;
  immatriculation_ends_with?: Maybe<String>;
  immatriculation_not_ends_with?: Maybe<String>;
  kilometrage?: Maybe<Float>;
  kilometrage_not?: Maybe<Float>;
  kilometrage_in?: Maybe<Float[] | Float>;
  kilometrage_not_in?: Maybe<Float[] | Float>;
  kilometrage_lt?: Maybe<Float>;
  kilometrage_lte?: Maybe<Float>;
  kilometrage_gt?: Maybe<Float>;
  kilometrage_gte?: Maybe<Float>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CarScalarWhereInput[] | CarScalarWhereInput>;
  OR?: Maybe<CarScalarWhereInput[] | CarScalarWhereInput>;
  NOT?: Maybe<CarScalarWhereInput[] | CarScalarWhereInput>;
}

export interface CarUpdateManyWithWhereNestedInput {
  where: CarScalarWhereInput;
  data: CarUpdateManyDataInput;
}

export interface CarUpdateManyDataInput {
  image?: Maybe<String>;
  marque?: Maybe<String>;
  capacity?: Maybe<Float>;
  type?: Maybe<String>;
  immatriculation?: Maybe<String>;
  kilometrage?: Maybe<Float>;
}

export interface DotationUpdateManyWithoutHoldInput {
  create?: Maybe<
    DotationCreateWithoutHoldInput[] | DotationCreateWithoutHoldInput
  >;
  delete?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  connect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  set?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  disconnect?: Maybe<DotationWhereUniqueInput[] | DotationWhereUniqueInput>;
  update?: Maybe<
    | DotationUpdateWithWhereUniqueWithoutHoldInput[]
    | DotationUpdateWithWhereUniqueWithoutHoldInput
  >;
  upsert?: Maybe<
    | DotationUpsertWithWhereUniqueWithoutHoldInput[]
    | DotationUpsertWithWhereUniqueWithoutHoldInput
  >;
  deleteMany?: Maybe<DotationScalarWhereInput[] | DotationScalarWhereInput>;
  updateMany?: Maybe<
    | DotationUpdateManyWithWhereNestedInput[]
    | DotationUpdateManyWithWhereNestedInput
  >;
}

export interface DotationUpdateWithWhereUniqueWithoutHoldInput {
  where: DotationWhereUniqueInput;
  data: DotationUpdateWithoutHoldDataInput;
}

export interface DotationUpdateWithoutHoldDataInput {
  motif?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
  user?: Maybe<UserUpdateOneWithoutDotationsInput>;
}

export interface UserUpdateOneWithoutDotationsInput {
  create?: Maybe<UserCreateWithoutDotationsInput>;
  update?: Maybe<UserUpdateWithoutDotationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutDotationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutDotationsDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  logs?: Maybe<LogUpdateManyWithoutUserInput>;
  bons?: Maybe<BonUpdateManyWithoutUserInput>;
  hold?: Maybe<HoldUpdateOneWithoutUserInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
}

export interface HoldUpdateOneWithoutUserInput {
  create?: Maybe<HoldCreateWithoutUserInput>;
  update?: Maybe<HoldUpdateWithoutUserDataInput>;
  upsert?: Maybe<HoldUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  bons?: Maybe<HoldsOnBonsUpdateManyWithoutHoldInput>;
  cars?: Maybe<CarUpdateManyWithoutHoldInput>;
  dotations?: Maybe<DotationUpdateManyWithoutHoldInput>;
}

export interface HoldsOnBonsUpdateManyWithoutHoldInput {
  create?: Maybe<
    HoldsOnBonsCreateWithoutHoldInput[] | HoldsOnBonsCreateWithoutHoldInput
  >;
  delete?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  connect?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  set?: Maybe<HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput>;
  disconnect?: Maybe<
    HoldsOnBonsWhereUniqueInput[] | HoldsOnBonsWhereUniqueInput
  >;
  update?: Maybe<
    | HoldsOnBonsUpdateWithWhereUniqueWithoutHoldInput[]
    | HoldsOnBonsUpdateWithWhereUniqueWithoutHoldInput
  >;
  upsert?: Maybe<
    | HoldsOnBonsUpsertWithWhereUniqueWithoutHoldInput[]
    | HoldsOnBonsUpsertWithWhereUniqueWithoutHoldInput
  >;
  deleteMany?: Maybe<
    HoldsOnBonsScalarWhereInput[] | HoldsOnBonsScalarWhereInput
  >;
}

export interface HoldsOnBonsUpdateWithWhereUniqueWithoutHoldInput {
  where: HoldsOnBonsWhereUniqueInput;
  data: HoldsOnBonsUpdateWithoutHoldDataInput;
}

export interface HoldsOnBonsUpdateWithoutHoldDataInput {
  bon?: Maybe<BonUpdateOneRequiredWithoutHoldsInput>;
}

export interface BonUpdateOneRequiredWithoutHoldsInput {
  create?: Maybe<BonCreateWithoutHoldsInput>;
  update?: Maybe<BonUpdateWithoutHoldsDataInput>;
  upsert?: Maybe<BonUpsertWithoutHoldsInput>;
  connect?: Maybe<BonWhereUniqueInput>;
}

export interface BonUpdateWithoutHoldsDataInput {
  consumed?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  destination?: Maybe<String>;
  fuel_type?: Maybe<String>;
  reason?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  status?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutBonsInput>;
  driver?: Maybe<String>;
}

export interface BonUpsertWithoutHoldsInput {
  update: BonUpdateWithoutHoldsDataInput;
  create: BonCreateWithoutHoldsInput;
}

export interface HoldsOnBonsUpsertWithWhereUniqueWithoutHoldInput {
  where: HoldsOnBonsWhereUniqueInput;
  update: HoldsOnBonsUpdateWithoutHoldDataInput;
  create: HoldsOnBonsCreateWithoutHoldInput;
}

export interface HoldsOnBonsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HoldsOnBonsScalarWhereInput[] | HoldsOnBonsScalarWhereInput>;
  OR?: Maybe<HoldsOnBonsScalarWhereInput[] | HoldsOnBonsScalarWhereInput>;
  NOT?: Maybe<HoldsOnBonsScalarWhereInput[] | HoldsOnBonsScalarWhereInput>;
}

export interface HoldUpsertWithoutUserInput {
  update: HoldUpdateWithoutUserDataInput;
  create: HoldCreateWithoutUserInput;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  delete?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  set?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  disconnect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  update?: Maybe<
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    NotificationScalarWhereInput[] | NotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput
  >;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface NotificationUpdateWithoutUserDataInput {
  message?: Maybe<String>;
}

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface NotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  OR?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  NOT?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface NotificationUpdateManyDataInput {
  message?: Maybe<String>;
}

export interface UserUpsertWithoutDotationsInput {
  update: UserUpdateWithoutDotationsDataInput;
  create: UserCreateWithoutDotationsInput;
}

export interface DotationUpsertWithWhereUniqueWithoutHoldInput {
  where: DotationWhereUniqueInput;
  update: DotationUpdateWithoutHoldDataInput;
  create: DotationCreateWithoutHoldInput;
}

export interface DotationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  motif?: Maybe<String>;
  motif_not?: Maybe<String>;
  motif_in?: Maybe<String[] | String>;
  motif_not_in?: Maybe<String[] | String>;
  motif_lt?: Maybe<String>;
  motif_lte?: Maybe<String>;
  motif_gt?: Maybe<String>;
  motif_gte?: Maybe<String>;
  motif_contains?: Maybe<String>;
  motif_not_contains?: Maybe<String>;
  motif_starts_with?: Maybe<String>;
  motif_not_starts_with?: Maybe<String>;
  motif_ends_with?: Maybe<String>;
  motif_not_ends_with?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  start_date_not?: Maybe<DateTimeInput>;
  start_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_date_lt?: Maybe<DateTimeInput>;
  start_date_lte?: Maybe<DateTimeInput>;
  start_date_gt?: Maybe<DateTimeInput>;
  start_date_gte?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  end_date_not?: Maybe<DateTimeInput>;
  end_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_date_lt?: Maybe<DateTimeInput>;
  end_date_lte?: Maybe<DateTimeInput>;
  end_date_gt?: Maybe<DateTimeInput>;
  end_date_gte?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_dotated_super_not?: Maybe<Float>;
  number_of_liter_dotated_super_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_super_lt?: Maybe<Float>;
  number_of_liter_dotated_super_lte?: Maybe<Float>;
  number_of_liter_dotated_super_gt?: Maybe<Float>;
  number_of_liter_dotated_super_gte?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_received_super_not?: Maybe<Float>;
  number_of_liter_received_super_in?: Maybe<Float[] | Float>;
  number_of_liter_received_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_super_lt?: Maybe<Float>;
  number_of_liter_received_super_lte?: Maybe<Float>;
  number_of_liter_received_super_gt?: Maybe<Float>;
  number_of_liter_received_super_gte?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_dotated_gazoil_not?: Maybe<Float>;
  number_of_liter_dotated_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_gazoil_lt?: Maybe<Float>;
  number_of_liter_dotated_gazoil_lte?: Maybe<Float>;
  number_of_liter_dotated_gazoil_gt?: Maybe<Float>;
  number_of_liter_dotated_gazoil_gte?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil_not?: Maybe<Float>;
  number_of_liter_received_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_received_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_gazoil_lt?: Maybe<Float>;
  number_of_liter_received_gazoil_lte?: Maybe<Float>;
  number_of_liter_received_gazoil_gt?: Maybe<Float>;
  number_of_liter_received_gazoil_gte?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_not?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_super_lt?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_lte?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_gt?: Maybe<Float>;
  number_of_liter_dotated_reserve_super_gte?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super_not?: Maybe<Float>;
  number_of_liter_received_reserve_super_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_super_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_super_lt?: Maybe<Float>;
  number_of_liter_received_reserve_super_lte?: Maybe<Float>;
  number_of_liter_received_reserve_super_gt?: Maybe<Float>;
  number_of_liter_received_reserve_super_gte?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_not?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_dotated_reserve_gazoil_lt?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_lte?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_gt?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil_gte?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_not?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_gazoil_not_in?: Maybe<Float[] | Float>;
  number_of_liter_received_reserve_gazoil_lt?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_lte?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_gt?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil_gte?: Maybe<Float>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DotationScalarWhereInput[] | DotationScalarWhereInput>;
  OR?: Maybe<DotationScalarWhereInput[] | DotationScalarWhereInput>;
  NOT?: Maybe<DotationScalarWhereInput[] | DotationScalarWhereInput>;
}

export interface DotationUpdateManyWithWhereNestedInput {
  where: DotationScalarWhereInput;
  data: DotationUpdateManyDataInput;
}

export interface DotationUpdateManyDataInput {
  motif?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
}

export interface HoldUpsertWithoutBonsInput {
  update: HoldUpdateWithoutBonsDataInput;
  create: HoldCreateWithoutBonsInput;
}

export interface HoldsOnBonsUpsertWithWhereUniqueWithoutBonInput {
  where: HoldsOnBonsWhereUniqueInput;
  update: HoldsOnBonsUpdateWithoutBonDataInput;
  create: HoldsOnBonsCreateWithoutBonInput;
}

export interface BonUpsertWithWhereUniqueWithoutUserInput {
  where: BonWhereUniqueInput;
  update: BonUpdateWithoutUserDataInput;
  create: BonCreateWithoutUserInput;
}

export interface BonScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  consumed?: Maybe<Boolean>;
  consumed_not?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  coverage_when_consuming_not?: Maybe<Float>;
  coverage_when_consuming_in?: Maybe<Float[] | Float>;
  coverage_when_consuming_not_in?: Maybe<Float[] | Float>;
  coverage_when_consuming_lt?: Maybe<Float>;
  coverage_when_consuming_lte?: Maybe<Float>;
  coverage_when_consuming_gt?: Maybe<Float>;
  coverage_when_consuming_gte?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  expiration_date_not?: Maybe<String>;
  expiration_date_in?: Maybe<String[] | String>;
  expiration_date_not_in?: Maybe<String[] | String>;
  expiration_date_lt?: Maybe<String>;
  expiration_date_lte?: Maybe<String>;
  expiration_date_gt?: Maybe<String>;
  expiration_date_gte?: Maybe<String>;
  expiration_date_contains?: Maybe<String>;
  expiration_date_not_contains?: Maybe<String>;
  expiration_date_starts_with?: Maybe<String>;
  expiration_date_not_starts_with?: Maybe<String>;
  expiration_date_ends_with?: Maybe<String>;
  expiration_date_not_ends_with?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  consumed_date_not?: Maybe<DateTimeInput>;
  consumed_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  consumed_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  consumed_date_lt?: Maybe<DateTimeInput>;
  consumed_date_lte?: Maybe<DateTimeInput>;
  consumed_date_gt?: Maybe<DateTimeInput>;
  consumed_date_gte?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  emission_date_not?: Maybe<DateTimeInput>;
  emission_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emission_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emission_date_lt?: Maybe<DateTimeInput>;
  emission_date_lte?: Maybe<DateTimeInput>;
  emission_date_gt?: Maybe<DateTimeInput>;
  emission_date_gte?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  departure_not?: Maybe<String>;
  departure_in?: Maybe<String[] | String>;
  departure_not_in?: Maybe<String[] | String>;
  departure_lt?: Maybe<String>;
  departure_lte?: Maybe<String>;
  departure_gt?: Maybe<String>;
  departure_gte?: Maybe<String>;
  departure_contains?: Maybe<String>;
  departure_not_contains?: Maybe<String>;
  departure_starts_with?: Maybe<String>;
  departure_not_starts_with?: Maybe<String>;
  departure_ends_with?: Maybe<String>;
  departure_not_ends_with?: Maybe<String>;
  destination?: Maybe<String>;
  destination_not?: Maybe<String>;
  destination_in?: Maybe<String[] | String>;
  destination_not_in?: Maybe<String[] | String>;
  destination_lt?: Maybe<String>;
  destination_lte?: Maybe<String>;
  destination_gt?: Maybe<String>;
  destination_gte?: Maybe<String>;
  destination_contains?: Maybe<String>;
  destination_not_contains?: Maybe<String>;
  destination_starts_with?: Maybe<String>;
  destination_not_starts_with?: Maybe<String>;
  destination_ends_with?: Maybe<String>;
  destination_not_ends_with?: Maybe<String>;
  fuel_type?: Maybe<String>;
  fuel_type_not?: Maybe<String>;
  fuel_type_in?: Maybe<String[] | String>;
  fuel_type_not_in?: Maybe<String[] | String>;
  fuel_type_lt?: Maybe<String>;
  fuel_type_lte?: Maybe<String>;
  fuel_type_gt?: Maybe<String>;
  fuel_type_gte?: Maybe<String>;
  fuel_type_contains?: Maybe<String>;
  fuel_type_not_contains?: Maybe<String>;
  fuel_type_starts_with?: Maybe<String>;
  fuel_type_not_starts_with?: Maybe<String>;
  fuel_type_ends_with?: Maybe<String>;
  fuel_type_not_ends_with?: Maybe<String>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  number_of_liter_not?: Maybe<Float>;
  number_of_liter_in?: Maybe<Float[] | Float>;
  number_of_liter_not_in?: Maybe<Float[] | Float>;
  number_of_liter_lt?: Maybe<Float>;
  number_of_liter_lte?: Maybe<Float>;
  number_of_liter_gt?: Maybe<Float>;
  number_of_liter_gte?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  initial_number_of_liter_not?: Maybe<Float>;
  initial_number_of_liter_in?: Maybe<Float[] | Float>;
  initial_number_of_liter_not_in?: Maybe<Float[] | Float>;
  initial_number_of_liter_lt?: Maybe<Float>;
  initial_number_of_liter_lte?: Maybe<Float>;
  initial_number_of_liter_gt?: Maybe<Float>;
  initial_number_of_liter_gte?: Maybe<Float>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  driver?: Maybe<String>;
  driver_not?: Maybe<String>;
  driver_in?: Maybe<String[] | String>;
  driver_not_in?: Maybe<String[] | String>;
  driver_lt?: Maybe<String>;
  driver_lte?: Maybe<String>;
  driver_gt?: Maybe<String>;
  driver_gte?: Maybe<String>;
  driver_contains?: Maybe<String>;
  driver_not_contains?: Maybe<String>;
  driver_starts_with?: Maybe<String>;
  driver_not_starts_with?: Maybe<String>;
  driver_ends_with?: Maybe<String>;
  driver_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BonScalarWhereInput[] | BonScalarWhereInput>;
  OR?: Maybe<BonScalarWhereInput[] | BonScalarWhereInput>;
  NOT?: Maybe<BonScalarWhereInput[] | BonScalarWhereInput>;
}

export interface BonUpdateManyWithWhereNestedInput {
  where: BonScalarWhereInput;
  data: BonUpdateManyDataInput;
}

export interface BonUpdateManyDataInput {
  consumed?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  destination?: Maybe<String>;
  fuel_type?: Maybe<String>;
  reason?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  status?: Maybe<Boolean>;
  driver?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutHoldInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutHoldDataInput;
  create: UserCreateWithoutHoldInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  grade?: Maybe<String>;
  grade_not?: Maybe<String>;
  grade_in?: Maybe<String[] | String>;
  grade_not_in?: Maybe<String[] | String>;
  grade_lt?: Maybe<String>;
  grade_lte?: Maybe<String>;
  grade_gt?: Maybe<String>;
  grade_gte?: Maybe<String>;
  grade_contains?: Maybe<String>;
  grade_not_contains?: Maybe<String>;
  grade_starts_with?: Maybe<String>;
  grade_not_starts_with?: Maybe<String>;
  grade_ends_with?: Maybe<String>;
  grade_not_ends_with?: Maybe<String>;
  matricule?: Maybe<String>;
  matricule_not?: Maybe<String>;
  matricule_in?: Maybe<String[] | String>;
  matricule_not_in?: Maybe<String[] | String>;
  matricule_lt?: Maybe<String>;
  matricule_lte?: Maybe<String>;
  matricule_gt?: Maybe<String>;
  matricule_gte?: Maybe<String>;
  matricule_contains?: Maybe<String>;
  matricule_not_contains?: Maybe<String>;
  matricule_starts_with?: Maybe<String>;
  matricule_not_starts_with?: Maybe<String>;
  matricule_ends_with?: Maybe<String>;
  matricule_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  reserve?: Maybe<Float>;
  reserve_not?: Maybe<Float>;
  reserve_in?: Maybe<Float[] | Float>;
  reserve_not_in?: Maybe<Float[] | Float>;
  reserve_lt?: Maybe<Float>;
  reserve_lte?: Maybe<Float>;
  reserve_gt?: Maybe<Float>;
  reserve_gte?: Maybe<Float>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
}

export interface HoldUpsertWithoutDotationsInput {
  update: HoldUpdateWithoutDotationsDataInput;
  create: HoldCreateWithoutDotationsInput;
}

export interface DotationUpsertWithWhereUniqueWithoutUserInput {
  where: DotationWhereUniqueInput;
  update: DotationUpdateWithoutUserDataInput;
  create: DotationCreateWithoutUserInput;
}

export interface UserUpsertWithoutBonsInput {
  update: UserUpdateWithoutBonsDataInput;
  create: UserCreateWithoutBonsInput;
}

export interface BonUpdateManyMutationInput {
  consumed?: Maybe<Boolean>;
  coverage_when_consuming?: Maybe<Float>;
  expiration_date?: Maybe<String>;
  consumed_date?: Maybe<DateTimeInput>;
  emission_date?: Maybe<DateTimeInput>;
  departure?: Maybe<String>;
  destination?: Maybe<String>;
  fuel_type?: Maybe<String>;
  reason?: Maybe<String>;
  number_of_liter?: Maybe<Float>;
  initial_number_of_liter?: Maybe<Float>;
  status?: Maybe<Boolean>;
  driver?: Maybe<String>;
}

export interface CarCreateInput {
  id?: Maybe<ID_Input>;
  hold: HoldCreateOneWithoutCarsInput;
  image: String;
  marque: String;
  capacity: Float;
  type: String;
  immatriculation: String;
  kilometrage: Float;
}

export interface HoldCreateOneWithoutCarsInput {
  create?: Maybe<HoldCreateWithoutCarsInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldCreateWithoutCarsInput {
  id?: Maybe<ID_Input>;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  user?: Maybe<UserCreateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsCreateManyWithoutHoldInput>;
  dotations?: Maybe<DotationCreateManyWithoutHoldInput>;
}

export interface CarUpdateInput {
  hold?: Maybe<HoldUpdateOneRequiredWithoutCarsInput>;
  image?: Maybe<String>;
  marque?: Maybe<String>;
  capacity?: Maybe<Float>;
  type?: Maybe<String>;
  immatriculation?: Maybe<String>;
  kilometrage?: Maybe<Float>;
}

export interface HoldUpdateOneRequiredWithoutCarsInput {
  create?: Maybe<HoldCreateWithoutCarsInput>;
  update?: Maybe<HoldUpdateWithoutCarsDataInput>;
  upsert?: Maybe<HoldUpsertWithoutCarsInput>;
  connect?: Maybe<HoldWhereUniqueInput>;
}

export interface HoldUpdateWithoutCarsDataInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  user?: Maybe<UserUpdateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsUpdateManyWithoutHoldInput>;
  dotations?: Maybe<DotationUpdateManyWithoutHoldInput>;
}

export interface HoldUpsertWithoutCarsInput {
  update: HoldUpdateWithoutCarsDataInput;
  create: HoldCreateWithoutCarsInput;
}

export interface CarUpdateManyMutationInput {
  image?: Maybe<String>;
  marque?: Maybe<String>;
  capacity?: Maybe<Float>;
  type?: Maybe<String>;
  immatriculation?: Maybe<String>;
  kilometrage?: Maybe<Float>;
}

export interface DotationCreateInput {
  id?: Maybe<ID_Input>;
  motif: String;
  start_date: DateTimeInput;
  end_date: DateTimeInput;
  number_of_liter_dotated_super: Float;
  number_of_liter_received_super: Float;
  number_of_liter_dotated_gazoil: Float;
  number_of_liter_received_gazoil: Float;
  number_of_liter_dotated_reserve_super: Float;
  number_of_liter_received_reserve_super: Float;
  number_of_liter_dotated_reserve_gazoil: Float;
  number_of_liter_received_reserve_gazoil: Float;
  user?: Maybe<UserCreateOneWithoutDotationsInput>;
  hold?: Maybe<HoldCreateOneWithoutDotationsInput>;
}

export interface DotationUpdateInput {
  motif?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
  user?: Maybe<UserUpdateOneWithoutDotationsInput>;
  hold?: Maybe<HoldUpdateOneWithoutDotationsInput>;
}

export interface DotationUpdateManyMutationInput {
  motif?: Maybe<String>;
  start_date?: Maybe<DateTimeInput>;
  end_date?: Maybe<DateTimeInput>;
  number_of_liter_dotated_super?: Maybe<Float>;
  number_of_liter_received_super?: Maybe<Float>;
  number_of_liter_dotated_gazoil?: Maybe<Float>;
  number_of_liter_received_gazoil?: Maybe<Float>;
  number_of_liter_dotated_reserve_super?: Maybe<Float>;
  number_of_liter_received_reserve_super?: Maybe<Float>;
  number_of_liter_dotated_reserve_gazoil?: Maybe<Float>;
  number_of_liter_received_reserve_gazoil?: Maybe<Float>;
}

export interface HoldCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  user?: Maybe<UserCreateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsCreateManyWithoutHoldInput>;
  cars?: Maybe<CarCreateManyWithoutHoldInput>;
  dotations?: Maybe<DotationCreateManyWithoutHoldInput>;
}

export interface HoldUpdateInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
  user?: Maybe<UserUpdateManyWithoutHoldInput>;
  bons?: Maybe<HoldsOnBonsUpdateManyWithoutHoldInput>;
  cars?: Maybe<CarUpdateManyWithoutHoldInput>;
  dotations?: Maybe<DotationUpdateManyWithoutHoldInput>;
}

export interface HoldUpdateManyMutationInput {
  name?: Maybe<String>;
  localisation?: Maybe<String>;
  super_capacity?: Maybe<Float>;
  gazoil_capacity?: Maybe<Float>;
  super_quantity?: Maybe<Float>;
  gazoil_quantity?: Maybe<Float>;
  theorical_super_quantity?: Maybe<Float>;
  theorical_gazoil_quantity?: Maybe<Float>;
  reserve_super_quantity?: Maybe<Float>;
  reserve_gazoil_quantity?: Maybe<Float>;
  theorical_reserve_super_quantity?: Maybe<Float>;
  theorical_reserve_gazoil_quantity?: Maybe<Float>;
}

export interface HoldsOnBonsCreateInput {
  id?: Maybe<ID_Input>;
  hold: HoldCreateOneWithoutBonsInput;
  bon: BonCreateOneWithoutHoldsInput;
}

export interface HoldsOnBonsUpdateInput {
  hold?: Maybe<HoldUpdateOneRequiredWithoutBonsInput>;
  bon?: Maybe<BonUpdateOneRequiredWithoutHoldsInput>;
}

export interface LogCreateInput {
  id?: Maybe<ID_Input>;
  action: String;
  user: UserCreateOneWithoutLogsInput;
}

export interface UserCreateOneWithoutLogsInput {
  create?: Maybe<UserCreateWithoutLogsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutLogsInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  bons?: Maybe<BonCreateManyWithoutUserInput>;
  dotations?: Maybe<DotationCreateManyWithoutUserInput>;
  hold?: Maybe<HoldCreateOneWithoutUserInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
}

export interface LogUpdateInput {
  action?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutLogsInput>;
}

export interface UserUpdateOneRequiredWithoutLogsInput {
  create?: Maybe<UserCreateWithoutLogsInput>;
  update?: Maybe<UserUpdateWithoutLogsDataInput>;
  upsert?: Maybe<UserUpsertWithoutLogsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutLogsDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  bons?: Maybe<BonUpdateManyWithoutUserInput>;
  dotations?: Maybe<DotationUpdateManyWithoutUserInput>;
  hold?: Maybe<HoldUpdateOneWithoutUserInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutLogsInput {
  update: UserUpdateWithoutLogsDataInput;
  create: UserCreateWithoutLogsInput;
}

export interface LogUpdateManyMutationInput {
  action?: Maybe<String>;
}

export interface NotificationCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutNotificationsInput;
  message: String;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutNotificationsInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  logs?: Maybe<LogCreateManyWithoutUserInput>;
  bons?: Maybe<BonCreateManyWithoutUserInput>;
  dotations?: Maybe<DotationCreateManyWithoutUserInput>;
  hold?: Maybe<HoldCreateOneWithoutUserInput>;
}

export interface NotificationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutNotificationsInput>;
  message?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  update?: Maybe<UserUpdateWithoutNotificationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutNotificationsDataInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  logs?: Maybe<LogUpdateManyWithoutUserInput>;
  bons?: Maybe<BonUpdateManyWithoutUserInput>;
  dotations?: Maybe<DotationUpdateManyWithoutUserInput>;
  hold?: Maybe<HoldUpdateOneWithoutUserInput>;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface NotificationUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  logs?: Maybe<LogCreateManyWithoutUserInput>;
  bons?: Maybe<BonCreateManyWithoutUserInput>;
  dotations?: Maybe<DotationCreateManyWithoutUserInput>;
  hold?: Maybe<HoldCreateOneWithoutUserInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
}

export interface UserUpdateInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
  logs?: Maybe<LogUpdateManyWithoutUserInput>;
  bons?: Maybe<BonUpdateManyWithoutUserInput>;
  dotations?: Maybe<DotationUpdateManyWithoutUserInput>;
  hold?: Maybe<HoldUpdateOneWithoutUserInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  grade?: Maybe<String>;
  matricule?: Maybe<String>;
  username?: Maybe<String>;
  fullname?: Maybe<String>;
  phone?: Maybe<String>;
  reserve?: Maybe<Float>;
  role?: Maybe<String>;
  password?: Maybe<String>;
}

export interface BonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BonWhereInput>;
  AND?: Maybe<BonSubscriptionWhereInput[] | BonSubscriptionWhereInput>;
  OR?: Maybe<BonSubscriptionWhereInput[] | BonSubscriptionWhereInput>;
  NOT?: Maybe<BonSubscriptionWhereInput[] | BonSubscriptionWhereInput>;
}

export interface CarSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CarWhereInput>;
  AND?: Maybe<CarSubscriptionWhereInput[] | CarSubscriptionWhereInput>;
  OR?: Maybe<CarSubscriptionWhereInput[] | CarSubscriptionWhereInput>;
  NOT?: Maybe<CarSubscriptionWhereInput[] | CarSubscriptionWhereInput>;
}

export interface DotationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DotationWhereInput>;
  AND?: Maybe<
    DotationSubscriptionWhereInput[] | DotationSubscriptionWhereInput
  >;
  OR?: Maybe<DotationSubscriptionWhereInput[] | DotationSubscriptionWhereInput>;
  NOT?: Maybe<
    DotationSubscriptionWhereInput[] | DotationSubscriptionWhereInput
  >;
}

export interface HoldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HoldWhereInput>;
  AND?: Maybe<HoldSubscriptionWhereInput[] | HoldSubscriptionWhereInput>;
  OR?: Maybe<HoldSubscriptionWhereInput[] | HoldSubscriptionWhereInput>;
  NOT?: Maybe<HoldSubscriptionWhereInput[] | HoldSubscriptionWhereInput>;
}

export interface HoldsOnBonsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HoldsOnBonsWhereInput>;
  AND?: Maybe<
    HoldsOnBonsSubscriptionWhereInput[] | HoldsOnBonsSubscriptionWhereInput
  >;
  OR?: Maybe<
    HoldsOnBonsSubscriptionWhereInput[] | HoldsOnBonsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    HoldsOnBonsSubscriptionWhereInput[] | HoldsOnBonsSubscriptionWhereInput
  >;
}

export interface LogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LogWhereInput>;
  AND?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  OR?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  NOT?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Bon {
  id: ID_Output;
  consumed: Boolean;
  coverage_when_consuming: Float;
  expiration_date: String;
  consumed_date?: DateTimeOutput;
  emission_date: DateTimeOutput;
  departure: String;
  destination: String;
  fuel_type: String;
  reason: String;
  number_of_liter: Float;
  initial_number_of_liter: Float;
  status: Boolean;
  driver: String;
  created_at: DateTimeOutput;
}

export interface BonPromise extends Promise<Bon>, Fragmentable {
  id: () => Promise<ID_Output>;
  consumed: () => Promise<Boolean>;
  coverage_when_consuming: () => Promise<Float>;
  expiration_date: () => Promise<String>;
  consumed_date: () => Promise<DateTimeOutput>;
  emission_date: () => Promise<DateTimeOutput>;
  departure: () => Promise<String>;
  destination: () => Promise<String>;
  fuel_type: () => Promise<String>;
  reason: () => Promise<String>;
  number_of_liter: () => Promise<Float>;
  initial_number_of_liter: () => Promise<Float>;
  status: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  holds: <T = FragmentableArray<HoldsOnBons>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  driver: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface BonSubscription
  extends Promise<AsyncIterator<Bon>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  consumed: () => Promise<AsyncIterator<Boolean>>;
  coverage_when_consuming: () => Promise<AsyncIterator<Float>>;
  expiration_date: () => Promise<AsyncIterator<String>>;
  consumed_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  emission_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  departure: () => Promise<AsyncIterator<String>>;
  destination: () => Promise<AsyncIterator<String>>;
  fuel_type: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  number_of_liter: () => Promise<AsyncIterator<Float>>;
  initial_number_of_liter: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
  holds: <T = Promise<AsyncIterator<HoldsOnBonsSubscription>>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  driver: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BonNullablePromise extends Promise<Bon | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  consumed: () => Promise<Boolean>;
  coverage_when_consuming: () => Promise<Float>;
  expiration_date: () => Promise<String>;
  consumed_date: () => Promise<DateTimeOutput>;
  emission_date: () => Promise<DateTimeOutput>;
  departure: () => Promise<String>;
  destination: () => Promise<String>;
  fuel_type: () => Promise<String>;
  reason: () => Promise<String>;
  number_of_liter: () => Promise<Float>;
  initial_number_of_liter: () => Promise<Float>;
  status: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  holds: <T = FragmentableArray<HoldsOnBons>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  driver: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  created_at: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  active: () => Promise<Boolean>;
  grade: () => Promise<String>;
  matricule: () => Promise<String>;
  username: () => Promise<String>;
  fullname: () => Promise<String>;
  phone: () => Promise<String>;
  reserve: () => Promise<Float>;
  role: () => Promise<String>;
  password: () => Promise<String>;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = FragmentableArray<Bon>>(args?: {
    where?: BonWhereInput;
    orderBy?: BonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = FragmentableArray<Dotation>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hold: <T = HoldPromise>() => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  grade: () => Promise<AsyncIterator<String>>;
  matricule: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  reserve: () => Promise<AsyncIterator<Float>>;
  role: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  logs: <T = Promise<AsyncIterator<LogSubscription>>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = Promise<AsyncIterator<BonSubscription>>>(args?: {
    where?: BonWhereInput;
    orderBy?: BonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = Promise<AsyncIterator<DotationSubscription>>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hold: <T = HoldSubscription>() => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  active: () => Promise<Boolean>;
  grade: () => Promise<String>;
  matricule: () => Promise<String>;
  username: () => Promise<String>;
  fullname: () => Promise<String>;
  phone: () => Promise<String>;
  reserve: () => Promise<Float>;
  role: () => Promise<String>;
  password: () => Promise<String>;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = FragmentableArray<Bon>>(args?: {
    where?: BonWhereInput;
    orderBy?: BonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = FragmentableArray<Dotation>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hold: <T = HoldPromise>() => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface Log {
  id: ID_Output;
  action: String;
  created_at: DateTimeOutput;
}

export interface LogPromise extends Promise<Log>, Fragmentable {
  id: () => Promise<ID_Output>;
  action: () => Promise<String>;
  user: <T = UserPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface LogSubscription
  extends Promise<AsyncIterator<Log>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  action: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LogNullablePromise extends Promise<Log | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  action: () => Promise<String>;
  user: <T = UserPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface Dotation {
  id: ID_Output;
  motif: String;
  start_date: DateTimeOutput;
  end_date: DateTimeOutput;
  number_of_liter_dotated_super: Float;
  number_of_liter_received_super: Float;
  number_of_liter_dotated_gazoil: Float;
  number_of_liter_received_gazoil: Float;
  number_of_liter_dotated_reserve_super: Float;
  number_of_liter_received_reserve_super: Float;
  number_of_liter_dotated_reserve_gazoil: Float;
  number_of_liter_received_reserve_gazoil: Float;
  created_at: DateTimeOutput;
}

export interface DotationPromise extends Promise<Dotation>, Fragmentable {
  id: () => Promise<ID_Output>;
  motif: () => Promise<String>;
  start_date: () => Promise<DateTimeOutput>;
  end_date: () => Promise<DateTimeOutput>;
  number_of_liter_dotated_super: () => Promise<Float>;
  number_of_liter_received_super: () => Promise<Float>;
  number_of_liter_dotated_gazoil: () => Promise<Float>;
  number_of_liter_received_gazoil: () => Promise<Float>;
  number_of_liter_dotated_reserve_super: () => Promise<Float>;
  number_of_liter_received_reserve_super: () => Promise<Float>;
  number_of_liter_dotated_reserve_gazoil: () => Promise<Float>;
  number_of_liter_received_reserve_gazoil: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  hold: <T = HoldPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface DotationSubscription
  extends Promise<AsyncIterator<Dotation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  motif: () => Promise<AsyncIterator<String>>;
  start_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  end_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  number_of_liter_dotated_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_reserve_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_reserve_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_reserve_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_reserve_gazoil: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  hold: <T = HoldSubscription>() => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DotationNullablePromise
  extends Promise<Dotation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  motif: () => Promise<String>;
  start_date: () => Promise<DateTimeOutput>;
  end_date: () => Promise<DateTimeOutput>;
  number_of_liter_dotated_super: () => Promise<Float>;
  number_of_liter_received_super: () => Promise<Float>;
  number_of_liter_dotated_gazoil: () => Promise<Float>;
  number_of_liter_received_gazoil: () => Promise<Float>;
  number_of_liter_dotated_reserve_super: () => Promise<Float>;
  number_of_liter_received_reserve_super: () => Promise<Float>;
  number_of_liter_dotated_reserve_gazoil: () => Promise<Float>;
  number_of_liter_received_reserve_gazoil: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  hold: <T = HoldPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface Hold {
  id: ID_Output;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  created_at: DateTimeOutput;
}

export interface HoldPromise extends Promise<Hold>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  localisation: () => Promise<String>;
  super_capacity: () => Promise<Float>;
  gazoil_capacity: () => Promise<Float>;
  super_quantity: () => Promise<Float>;
  gazoil_quantity: () => Promise<Float>;
  theorical_super_quantity: () => Promise<Float>;
  theorical_gazoil_quantity: () => Promise<Float>;
  reserve_super_quantity: () => Promise<Float>;
  reserve_gazoil_quantity: () => Promise<Float>;
  theorical_reserve_super_quantity: () => Promise<Float>;
  theorical_reserve_gazoil_quantity: () => Promise<Float>;
  user: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = FragmentableArray<HoldsOnBons>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cars: <T = FragmentableArray<Car>>(args?: {
    where?: CarWhereInput;
    orderBy?: CarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = FragmentableArray<Dotation>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface HoldSubscription
  extends Promise<AsyncIterator<Hold>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  localisation: () => Promise<AsyncIterator<String>>;
  super_capacity: () => Promise<AsyncIterator<Float>>;
  gazoil_capacity: () => Promise<AsyncIterator<Float>>;
  super_quantity: () => Promise<AsyncIterator<Float>>;
  gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_super_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  reserve_super_quantity: () => Promise<AsyncIterator<Float>>;
  reserve_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_reserve_super_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_reserve_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  user: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = Promise<AsyncIterator<HoldsOnBonsSubscription>>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cars: <T = Promise<AsyncIterator<CarSubscription>>>(args?: {
    where?: CarWhereInput;
    orderBy?: CarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = Promise<AsyncIterator<DotationSubscription>>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HoldNullablePromise
  extends Promise<Hold | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  localisation: () => Promise<String>;
  super_capacity: () => Promise<Float>;
  gazoil_capacity: () => Promise<Float>;
  super_quantity: () => Promise<Float>;
  gazoil_quantity: () => Promise<Float>;
  theorical_super_quantity: () => Promise<Float>;
  theorical_gazoil_quantity: () => Promise<Float>;
  reserve_super_quantity: () => Promise<Float>;
  reserve_gazoil_quantity: () => Promise<Float>;
  theorical_reserve_super_quantity: () => Promise<Float>;
  theorical_reserve_gazoil_quantity: () => Promise<Float>;
  user: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bons: <T = FragmentableArray<HoldsOnBons>>(args?: {
    where?: HoldsOnBonsWhereInput;
    orderBy?: HoldsOnBonsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cars: <T = FragmentableArray<Car>>(args?: {
    where?: CarWhereInput;
    orderBy?: CarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dotations: <T = FragmentableArray<Dotation>>(args?: {
    where?: DotationWhereInput;
    orderBy?: DotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface HoldsOnBons {
  id: ID_Output;
  created_at: DateTimeOutput;
}

export interface HoldsOnBonsPromise extends Promise<HoldsOnBons>, Fragmentable {
  id: () => Promise<ID_Output>;
  hold: <T = HoldPromise>() => T;
  bon: <T = BonPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface HoldsOnBonsSubscription
  extends Promise<AsyncIterator<HoldsOnBons>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hold: <T = HoldSubscription>() => T;
  bon: <T = BonSubscription>() => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HoldsOnBonsNullablePromise
  extends Promise<HoldsOnBons | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hold: <T = HoldPromise>() => T;
  bon: <T = BonPromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
}

export interface Car {
  id: ID_Output;
  image: String;
  marque: String;
  capacity: Float;
  type: String;
  immatriculation: String;
  kilometrage: Float;
  created_at: DateTimeOutput;
}

export interface CarPromise extends Promise<Car>, Fragmentable {
  id: () => Promise<ID_Output>;
  hold: <T = HoldPromise>() => T;
  image: () => Promise<String>;
  marque: () => Promise<String>;
  capacity: () => Promise<Float>;
  type: () => Promise<String>;
  immatriculation: () => Promise<String>;
  kilometrage: () => Promise<Float>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface CarSubscription
  extends Promise<AsyncIterator<Car>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hold: <T = HoldSubscription>() => T;
  image: () => Promise<AsyncIterator<String>>;
  marque: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<String>>;
  immatriculation: () => Promise<AsyncIterator<String>>;
  kilometrage: () => Promise<AsyncIterator<Float>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CarNullablePromise extends Promise<Car | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  hold: <T = HoldPromise>() => T;
  image: () => Promise<String>;
  marque: () => Promise<String>;
  capacity: () => Promise<Float>;
  type: () => Promise<String>;
  immatriculation: () => Promise<String>;
  kilometrage: () => Promise<Float>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface Notification {
  id: ID_Output;
  message: String;
  created_at: DateTimeOutput;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  message: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  message: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface BonConnection {
  pageInfo: PageInfo;
  edges: BonEdge[];
}

export interface BonConnectionPromise
  extends Promise<BonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BonEdge>>() => T;
  aggregate: <T = AggregateBonPromise>() => T;
}

export interface BonConnectionSubscription
  extends Promise<AsyncIterator<BonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBonSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BonEdge {
  node: Bon;
  cursor: String;
}

export interface BonEdgePromise extends Promise<BonEdge>, Fragmentable {
  node: <T = BonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BonEdgeSubscription
  extends Promise<AsyncIterator<BonEdge>>,
    Fragmentable {
  node: <T = BonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBon {
  count: Int;
}

export interface AggregateBonPromise
  extends Promise<AggregateBon>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBonSubscription
  extends Promise<AsyncIterator<AggregateBon>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CarConnection {
  pageInfo: PageInfo;
  edges: CarEdge[];
}

export interface CarConnectionPromise
  extends Promise<CarConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CarEdge>>() => T;
  aggregate: <T = AggregateCarPromise>() => T;
}

export interface CarConnectionSubscription
  extends Promise<AsyncIterator<CarConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CarEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCarSubscription>() => T;
}

export interface CarEdge {
  node: Car;
  cursor: String;
}

export interface CarEdgePromise extends Promise<CarEdge>, Fragmentable {
  node: <T = CarPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CarEdgeSubscription
  extends Promise<AsyncIterator<CarEdge>>,
    Fragmentable {
  node: <T = CarSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCar {
  count: Int;
}

export interface AggregateCarPromise
  extends Promise<AggregateCar>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCarSubscription
  extends Promise<AsyncIterator<AggregateCar>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotationConnection {
  pageInfo: PageInfo;
  edges: DotationEdge[];
}

export interface DotationConnectionPromise
  extends Promise<DotationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotationEdge>>() => T;
  aggregate: <T = AggregateDotationPromise>() => T;
}

export interface DotationConnectionSubscription
  extends Promise<AsyncIterator<DotationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotationSubscription>() => T;
}

export interface DotationEdge {
  node: Dotation;
  cursor: String;
}

export interface DotationEdgePromise
  extends Promise<DotationEdge>,
    Fragmentable {
  node: <T = DotationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotationEdgeSubscription
  extends Promise<AsyncIterator<DotationEdge>>,
    Fragmentable {
  node: <T = DotationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDotation {
  count: Int;
}

export interface AggregateDotationPromise
  extends Promise<AggregateDotation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotationSubscription
  extends Promise<AsyncIterator<AggregateDotation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HoldConnection {
  pageInfo: PageInfo;
  edges: HoldEdge[];
}

export interface HoldConnectionPromise
  extends Promise<HoldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HoldEdge>>() => T;
  aggregate: <T = AggregateHoldPromise>() => T;
}

export interface HoldConnectionSubscription
  extends Promise<AsyncIterator<HoldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HoldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHoldSubscription>() => T;
}

export interface HoldEdge {
  node: Hold;
  cursor: String;
}

export interface HoldEdgePromise extends Promise<HoldEdge>, Fragmentable {
  node: <T = HoldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HoldEdgeSubscription
  extends Promise<AsyncIterator<HoldEdge>>,
    Fragmentable {
  node: <T = HoldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHold {
  count: Int;
}

export interface AggregateHoldPromise
  extends Promise<AggregateHold>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHoldSubscription
  extends Promise<AsyncIterator<AggregateHold>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HoldsOnBonsConnection {
  pageInfo: PageInfo;
  edges: HoldsOnBonsEdge[];
}

export interface HoldsOnBonsConnectionPromise
  extends Promise<HoldsOnBonsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HoldsOnBonsEdge>>() => T;
  aggregate: <T = AggregateHoldsOnBonsPromise>() => T;
}

export interface HoldsOnBonsConnectionSubscription
  extends Promise<AsyncIterator<HoldsOnBonsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HoldsOnBonsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHoldsOnBonsSubscription>() => T;
}

export interface HoldsOnBonsEdge {
  node: HoldsOnBons;
  cursor: String;
}

export interface HoldsOnBonsEdgePromise
  extends Promise<HoldsOnBonsEdge>,
    Fragmentable {
  node: <T = HoldsOnBonsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HoldsOnBonsEdgeSubscription
  extends Promise<AsyncIterator<HoldsOnBonsEdge>>,
    Fragmentable {
  node: <T = HoldsOnBonsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHoldsOnBons {
  count: Int;
}

export interface AggregateHoldsOnBonsPromise
  extends Promise<AggregateHoldsOnBons>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHoldsOnBonsSubscription
  extends Promise<AsyncIterator<AggregateHoldsOnBons>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LogConnection {
  pageInfo: PageInfo;
  edges: LogEdge[];
}

export interface LogConnectionPromise
  extends Promise<LogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogEdge>>() => T;
  aggregate: <T = AggregateLogPromise>() => T;
}

export interface LogConnectionSubscription
  extends Promise<AsyncIterator<LogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSubscription>() => T;
}

export interface LogEdge {
  node: Log;
  cursor: String;
}

export interface LogEdgePromise extends Promise<LogEdge>, Fragmentable {
  node: <T = LogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogEdgeSubscription
  extends Promise<AsyncIterator<LogEdge>>,
    Fragmentable {
  node: <T = LogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLog {
  count: Int;
}

export interface AggregateLogPromise
  extends Promise<AggregateLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSubscription
  extends Promise<AsyncIterator<AggregateLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BonSubscriptionPayload {
  mutation: MutationType;
  node: Bon;
  updatedFields: String[];
  previousValues: BonPreviousValues;
}

export interface BonSubscriptionPayloadPromise
  extends Promise<BonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BonPreviousValuesPromise>() => T;
}

export interface BonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BonPreviousValuesSubscription>() => T;
}

export interface BonPreviousValues {
  id: ID_Output;
  consumed: Boolean;
  coverage_when_consuming: Float;
  expiration_date: String;
  consumed_date?: DateTimeOutput;
  emission_date: DateTimeOutput;
  departure: String;
  destination: String;
  fuel_type: String;
  reason: String;
  number_of_liter: Float;
  initial_number_of_liter: Float;
  status: Boolean;
  driver: String;
  created_at: DateTimeOutput;
}

export interface BonPreviousValuesPromise
  extends Promise<BonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  consumed: () => Promise<Boolean>;
  coverage_when_consuming: () => Promise<Float>;
  expiration_date: () => Promise<String>;
  consumed_date: () => Promise<DateTimeOutput>;
  emission_date: () => Promise<DateTimeOutput>;
  departure: () => Promise<String>;
  destination: () => Promise<String>;
  fuel_type: () => Promise<String>;
  reason: () => Promise<String>;
  number_of_liter: () => Promise<Float>;
  initial_number_of_liter: () => Promise<Float>;
  status: () => Promise<Boolean>;
  driver: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface BonPreviousValuesSubscription
  extends Promise<AsyncIterator<BonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  consumed: () => Promise<AsyncIterator<Boolean>>;
  coverage_when_consuming: () => Promise<AsyncIterator<Float>>;
  expiration_date: () => Promise<AsyncIterator<String>>;
  consumed_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  emission_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  departure: () => Promise<AsyncIterator<String>>;
  destination: () => Promise<AsyncIterator<String>>;
  fuel_type: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  number_of_liter: () => Promise<AsyncIterator<Float>>;
  initial_number_of_liter: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<Boolean>>;
  driver: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CarSubscriptionPayload {
  mutation: MutationType;
  node: Car;
  updatedFields: String[];
  previousValues: CarPreviousValues;
}

export interface CarSubscriptionPayloadPromise
  extends Promise<CarSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CarPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CarPreviousValuesPromise>() => T;
}

export interface CarSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CarSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CarSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CarPreviousValuesSubscription>() => T;
}

export interface CarPreviousValues {
  id: ID_Output;
  image: String;
  marque: String;
  capacity: Float;
  type: String;
  immatriculation: String;
  kilometrage: Float;
  created_at: DateTimeOutput;
}

export interface CarPreviousValuesPromise
  extends Promise<CarPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  marque: () => Promise<String>;
  capacity: () => Promise<Float>;
  type: () => Promise<String>;
  immatriculation: () => Promise<String>;
  kilometrage: () => Promise<Float>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface CarPreviousValuesSubscription
  extends Promise<AsyncIterator<CarPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  marque: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<String>>;
  immatriculation: () => Promise<AsyncIterator<String>>;
  kilometrage: () => Promise<AsyncIterator<Float>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DotationSubscriptionPayload {
  mutation: MutationType;
  node: Dotation;
  updatedFields: String[];
  previousValues: DotationPreviousValues;
}

export interface DotationSubscriptionPayloadPromise
  extends Promise<DotationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotationPreviousValuesPromise>() => T;
}

export interface DotationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotationPreviousValuesSubscription>() => T;
}

export interface DotationPreviousValues {
  id: ID_Output;
  motif: String;
  start_date: DateTimeOutput;
  end_date: DateTimeOutput;
  number_of_liter_dotated_super: Float;
  number_of_liter_received_super: Float;
  number_of_liter_dotated_gazoil: Float;
  number_of_liter_received_gazoil: Float;
  number_of_liter_dotated_reserve_super: Float;
  number_of_liter_received_reserve_super: Float;
  number_of_liter_dotated_reserve_gazoil: Float;
  number_of_liter_received_reserve_gazoil: Float;
  created_at: DateTimeOutput;
}

export interface DotationPreviousValuesPromise
  extends Promise<DotationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  motif: () => Promise<String>;
  start_date: () => Promise<DateTimeOutput>;
  end_date: () => Promise<DateTimeOutput>;
  number_of_liter_dotated_super: () => Promise<Float>;
  number_of_liter_received_super: () => Promise<Float>;
  number_of_liter_dotated_gazoil: () => Promise<Float>;
  number_of_liter_received_gazoil: () => Promise<Float>;
  number_of_liter_dotated_reserve_super: () => Promise<Float>;
  number_of_liter_received_reserve_super: () => Promise<Float>;
  number_of_liter_dotated_reserve_gazoil: () => Promise<Float>;
  number_of_liter_received_reserve_gazoil: () => Promise<Float>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface DotationPreviousValuesSubscription
  extends Promise<AsyncIterator<DotationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  motif: () => Promise<AsyncIterator<String>>;
  start_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  end_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  number_of_liter_dotated_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_reserve_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_reserve_super: () => Promise<AsyncIterator<Float>>;
  number_of_liter_dotated_reserve_gazoil: () => Promise<AsyncIterator<Float>>;
  number_of_liter_received_reserve_gazoil: () => Promise<AsyncIterator<Float>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HoldSubscriptionPayload {
  mutation: MutationType;
  node: Hold;
  updatedFields: String[];
  previousValues: HoldPreviousValues;
}

export interface HoldSubscriptionPayloadPromise
  extends Promise<HoldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HoldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HoldPreviousValuesPromise>() => T;
}

export interface HoldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HoldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HoldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HoldPreviousValuesSubscription>() => T;
}

export interface HoldPreviousValues {
  id: ID_Output;
  name: String;
  localisation: String;
  super_capacity: Float;
  gazoil_capacity: Float;
  super_quantity: Float;
  gazoil_quantity: Float;
  theorical_super_quantity: Float;
  theorical_gazoil_quantity: Float;
  reserve_super_quantity: Float;
  reserve_gazoil_quantity: Float;
  theorical_reserve_super_quantity: Float;
  theorical_reserve_gazoil_quantity: Float;
  created_at: DateTimeOutput;
}

export interface HoldPreviousValuesPromise
  extends Promise<HoldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  localisation: () => Promise<String>;
  super_capacity: () => Promise<Float>;
  gazoil_capacity: () => Promise<Float>;
  super_quantity: () => Promise<Float>;
  gazoil_quantity: () => Promise<Float>;
  theorical_super_quantity: () => Promise<Float>;
  theorical_gazoil_quantity: () => Promise<Float>;
  reserve_super_quantity: () => Promise<Float>;
  reserve_gazoil_quantity: () => Promise<Float>;
  theorical_reserve_super_quantity: () => Promise<Float>;
  theorical_reserve_gazoil_quantity: () => Promise<Float>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface HoldPreviousValuesSubscription
  extends Promise<AsyncIterator<HoldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  localisation: () => Promise<AsyncIterator<String>>;
  super_capacity: () => Promise<AsyncIterator<Float>>;
  gazoil_capacity: () => Promise<AsyncIterator<Float>>;
  super_quantity: () => Promise<AsyncIterator<Float>>;
  gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_super_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  reserve_super_quantity: () => Promise<AsyncIterator<Float>>;
  reserve_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_reserve_super_quantity: () => Promise<AsyncIterator<Float>>;
  theorical_reserve_gazoil_quantity: () => Promise<AsyncIterator<Float>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HoldsOnBonsSubscriptionPayload {
  mutation: MutationType;
  node: HoldsOnBons;
  updatedFields: String[];
  previousValues: HoldsOnBonsPreviousValues;
}

export interface HoldsOnBonsSubscriptionPayloadPromise
  extends Promise<HoldsOnBonsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HoldsOnBonsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HoldsOnBonsPreviousValuesPromise>() => T;
}

export interface HoldsOnBonsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HoldsOnBonsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HoldsOnBonsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HoldsOnBonsPreviousValuesSubscription>() => T;
}

export interface HoldsOnBonsPreviousValues {
  id: ID_Output;
  created_at: DateTimeOutput;
}

export interface HoldsOnBonsPreviousValuesPromise
  extends Promise<HoldsOnBonsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface HoldsOnBonsPreviousValuesSubscription
  extends Promise<AsyncIterator<HoldsOnBonsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LogSubscriptionPayload {
  mutation: MutationType;
  node: Log;
  updatedFields: String[];
  previousValues: LogPreviousValues;
}

export interface LogSubscriptionPayloadPromise
  extends Promise<LogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogPreviousValuesPromise>() => T;
}

export interface LogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogPreviousValuesSubscription>() => T;
}

export interface LogPreviousValues {
  id: ID_Output;
  action: String;
  created_at: DateTimeOutput;
}

export interface LogPreviousValuesPromise
  extends Promise<LogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  action: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface LogPreviousValuesSubscription
  extends Promise<AsyncIterator<LogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  action: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  message: String;
  created_at: DateTimeOutput;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  active: Boolean;
  grade: String;
  matricule: String;
  username: String;
  fullname: String;
  phone: String;
  reserve: Float;
  role: String;
  password: String;
  created_at: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  active: () => Promise<Boolean>;
  grade: () => Promise<String>;
  matricule: () => Promise<String>;
  username: () => Promise<String>;
  fullname: () => Promise<String>;
  phone: () => Promise<String>;
  reserve: () => Promise<Float>;
  role: () => Promise<String>;
  password: () => Promise<String>;
  created_at: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  grade: () => Promise<AsyncIterator<String>>;
  matricule: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  reserve: () => Promise<AsyncIterator<Float>>;
  role: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Dotation",
    embedded: false
  },
  {
    name: "Log",
    embedded: false
  },
  {
    name: "Hold",
    embedded: false
  },
  {
    name: "HoldsOnBons",
    embedded: false
  },
  {
    name: "Bon",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "Car",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
